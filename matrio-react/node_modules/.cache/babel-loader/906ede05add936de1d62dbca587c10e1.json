{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('mousetrap'), require('flatted'), require('redux'), require('socket.io-client'), require('immer'), require('react-cookies')) : typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', 'mousetrap', 'flatted', 'redux', 'socket.io-client', 'immer', 'react-cookies'], factory) : (global = global || self, factory(global.Client = {}, global.React, global.PropTypes, global.Mousetrap, global.Flatted, global.Redux, global.io, global.immer, global.Cookies));\n})(this, function (exports, React, PropTypes, Mousetrap, flatted, redux, io, produce, Cookies) {\n  'use strict';\n\n  React = React && React.hasOwnProperty('default') ? React['default'] : React;\n  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;\n  Mousetrap = Mousetrap && Mousetrap.hasOwnProperty('default') ? Mousetrap['default'] : Mousetrap;\n  io = io && io.hasOwnProperty('default') ? io['default'] : io;\n  produce = produce && produce.hasOwnProperty('default') ? produce['default'] : produce;\n  Cookies = Cookies && Cookies.hasOwnProperty('default') ? Cookies['default'] : Cookies;\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n\n    return _assertThisInitialized(self);\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n  /*\n   * Copyright 2018 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n\n  function AssignShortcuts(moveNames, eventNames, blacklist) {\n    var shortcuts = {};\n    var events = {};\n\n    for (var name in moveNames) {\n      events[name] = name;\n    }\n\n    for (var _name in eventNames) {\n      events[_name] = _name;\n    }\n\n    var taken = {};\n\n    for (var i = 0; i < blacklist.length; i++) {\n      var c = blacklist[i];\n      taken[c] = true;\n    } // Try assigning the first char of each move as the shortcut.\n\n\n    var t = taken;\n    var canUseFirstChar = true;\n\n    for (var _name2 in events) {\n      var shortcut = _name2[0];\n\n      if (t[shortcut]) {\n        canUseFirstChar = false;\n        break;\n      }\n\n      t[shortcut] = true;\n      shortcuts[_name2] = shortcut;\n    }\n\n    if (canUseFirstChar) {\n      return shortcuts;\n    } // If those aren't unique, use a-z.\n\n\n    t = taken;\n    var next = 97;\n    shortcuts = {};\n\n    for (var _name3 in events) {\n      var _shortcut = String.fromCharCode(next);\n\n      while (t[_shortcut]) {\n        next++;\n        _shortcut = String.fromCharCode(next);\n      }\n\n      t[_shortcut] = true;\n      shortcuts[_name3] = _shortcut;\n    }\n\n    return shortcuts;\n  }\n  /*\n   * Copyright 2018 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n\n  var Item = function Item(props) {\n    return React.createElement(\"div\", {\n      className: \"gameinfo-item\"\n    }, React.createElement(\"strong\", null, props.name, \" \"), React.createElement(\"div\", null, JSON.stringify(props.value)));\n  };\n\n  Item.propTypes = {\n    name: PropTypes.string.isRequired,\n    value: PropTypes.any\n  };\n\n  var GameInfo = function GameInfo(props) {\n    return React.createElement(\"section\", {\n      className: \"gameinfo\"\n    }, React.createElement(Item, {\n      name: \"gameID\",\n      value: props.gameID\n    }), React.createElement(Item, {\n      name: \"playerID\",\n      value: props.playerID\n    }), React.createElement(Item, {\n      name: \"isActive\",\n      value: props.isActive\n    }), props.isMultiplayer && React.createElement(\"span\", null, React.createElement(Item, {\n      name: \"isConnected\",\n      value: props.isConnected\n    }), React.createElement(Item, {\n      name: \"isMultiplayer\",\n      value: props.isMultiplayer\n    })));\n  };\n\n  GameInfo.propTypes = {\n    gameID: PropTypes.string,\n    playerID: PropTypes.string,\n    isActive: PropTypes.bool,\n    isConnected: PropTypes.bool,\n    isMultiplayer: PropTypes.bool\n  };\n\n  function styleInject(css, ref) {\n    if (ref === void 0) ref = {};\n    var insertAt = ref.insertAt;\n\n    if (!css || typeof document === 'undefined') {\n      return;\n    }\n\n    var head = document.head || document.getElementsByTagName('head')[0];\n    var style = document.createElement('style');\n    style.type = 'text/css';\n\n    if (insertAt === 'top') {\n      if (head.firstChild) {\n        head.insertBefore(style, head.firstChild);\n      } else {\n        head.appendChild(style);\n      }\n    } else {\n      head.appendChild(style);\n    }\n\n    if (style.styleSheet) {\n      style.styleSheet.cssText = css;\n    } else {\n      style.appendChild(document.createTextNode(css));\n    }\n  }\n\n  var css = \"/*\\n * Copyright 2017 The boardgame.io Authors\\n *\\n * Use of this source code is governed by a MIT-style\\n * license that can be found in the LICENSE file or at\\n * https://opensource.org/licenses/MIT.\\n */\\n\\n.debug-ui {\\n  text-align: left;\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n  background: #fefefe;\\n  border-left: 1px solid #ddd;\\n  box-shadow: -1px 0 10px #aaa;\\n  position: absolute;\\n  width: 300px;\\n  right: 0;\\n  top: 0;\\n  height: 100%;\\n  font-family: monospace;\\n  font-size: 14px;\\n}\\n\\n#debug-controls.docktop {\\n  position: fixed;\\n  display: flex;\\n  flex-direction: row;\\n  justify-content: space-evenly;\\n  align-items: center;\\n  padding-left: 10px;\\n  padding-right: 10px;\\n  min-width: 500px;\\n  top: 0;\\n  right: 300px;\\n  height: 50px;\\n  background: #fff;\\n  box-shadow: -3px 3px 3px #ccc;\\n}\\n\\n@media only screen and (max-device-width: 750px) {\\n  .debug-ui {\\n    display: none;\\n  }\\n}\\n\\n.debug-ui .gameinfo {\\n  background: #ddd;\\n  position: fixed;\\n  bottom: 0;\\n  box-sizing: border-box;\\n  width: 285px;\\n  margin-left: -20px;\\n  margin-bottom: 0;\\n  padding: 10px;\\n}\\n\\n.debug-ui .gameinfo-item div {\\n  float: right;\\n  text-align: right;\\n}\\n\\n.debug-ui .ai-visualization {\\n  position: fixed;\\n  opacity: 100%;\\n  right: 300px;\\n  height: 100%;\\n  width: 100%;\\n  max-width: 3000px;\\n  background: #fafafa;\\n  border-right: 1px solid #ddd;\\n}\\n\\n.debug-ui .pane {\\n  float: left;\\n  padding: 20px;\\n  box-sizing: border-box;\\n  min-width: 300px;\\n  max-width: 400px;\\n  opacity: 0.8;\\n}\\n\\n.debug-ui section {\\n  margin-bottom: 20px;\\n}\\n\\n.debug-ui textarea {\\n  resize: none;\\n}\\n\\n.debug-ui .move {\\n  cursor: pointer;\\n  margin-bottom: 10px;\\n  color: #666;\\n}\\n\\n.debug-ui .move:hover {\\n  color: #333;\\n}\\n\\n.debug-ui .move.active {\\n  color: #111;\\n  font-weight: bold;\\n}\\n\\n.debug-ui .move-error {\\n  color: #a00;\\n  font-weight: bold;\\n}\\n\\n.debug-ui .arg-field {\\n  outline: none;\\n  font-family: monospace;\\n}\\n\\n.debug-ui .key {\\n  margin-bottom: 5px;\\n}\\n\\n.debug-ui .key-box {\\n  display: inline-block;\\n  cursor: pointer;\\n  min-width: 10px;\\n  padding-left: 5px;\\n  padding-right: 5px;\\n  height: 20px;\\n  line-height: 20px;\\n  text-align: center;\\n  border: 1px solid #ccc;\\n  box-shadow: 1px 1px 1px #888;\\n  background: #eee;\\n  color: #444;\\n}\\n\\n.debug-ui .key-box:hover {\\n  background: #ddd;\\n}\\n\\n.debug-ui .key.active .key-box {\\n  background: #ddd;\\n  border: 1px solid #999;\\n  box-shadow: none;\\n}\\n\\n.debug-ui .key-child {\\n  display: inline-block;\\n  height: 20px;\\n  margin-left: 10px;\\n}\\n\\n.debug-ui .menu {\\n  display: flex;\\n  flex-direction: row;\\n  justify-content: center;\\n}\\n\\n.debug-ui .menu .item {\\n  cursor: pointer;\\n  margin-top: -10px;\\n  margin-bottom: 20px;\\n  margin-right: 10px;\\n  padding: 5px;\\n  min-width: 50px;\\n  text-align: center;\\n}\\n\\n.debug-ui .menu .item.active {\\n  font-weight: bold;\\n  border-bottom: 3px solid #ccc;\\n}\\n\\n.debug-ui .player-box {\\n  display: flex;\\n  flex-direction: row;\\n}\\n\\n.debug-ui .player {\\n  cursor: pointer;\\n  text-align: center;\\n  width: 30px;\\n  height: 30px;\\n  line-height: 30px;\\n  background: #eee;\\n  border: 3px solid #fff;\\n  box-sizing: content-box;\\n}\\n\\n.debug-ui .player.current {\\n  background: #555;\\n  color: #eee;\\n  font-weight: bold;\\n}\\n\\n.debug-ui .player.active {\\n  border: 3px solid #ff7f50;\\n}\\n\";\n  styleInject(css);\n  /**\n   * KeyboardShortcut\n   *\n   * Registers a keyboard shortcut to activate the\n   * associated child component that is passed in.\n   *\n   * When the key is pressed, 'active' is set to true\n   * in the prop passed to the child.\n   */\n\n  var KeyboardShortcut =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(KeyboardShortcut, _React$Component);\n\n    function KeyboardShortcut() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      _classCallCheck(this, KeyboardShortcut);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(KeyboardShortcut)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n        active: false\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"deactivate\", function () {\n        _this.setState({\n          active: false\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"activate\", function () {\n        _this.setState({\n          active: true\n        });\n\n        if (_this.props.onPress) {\n          _this.props.onPress();\n\n          _this.setState({\n            active: false\n          });\n        }\n      });\n\n      return _this;\n    }\n\n    _createClass(KeyboardShortcut, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        Mousetrap.bind(this.props.value, function (e) {\n          e.preventDefault();\n\n          _this2.activate();\n        });\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        Mousetrap.unbind(this.props.value);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var child = this.props.children;\n\n        if (_typeof(this.props.children) === _typeof(this)) {\n          child = React.cloneElement(this.props.children, {\n            active: this.state.active,\n            deactivate: this.deactivate,\n            activate: this.activate\n          });\n        }\n\n        var className = 'key';\n\n        if (this.state.active) {\n          className += ' active';\n        }\n\n        return React.createElement(\"div\", {\n          className: className\n        }, React.createElement(\"div\", {\n          className: \"key-box\",\n          onClick: this.activate\n        }, this.props.value), React.createElement(\"div\", {\n          className: \"key-child\"\n        }, child));\n      }\n    }]);\n\n    return KeyboardShortcut;\n  }(React.Component);\n\n  _defineProperty(KeyboardShortcut, \"propTypes\", {\n    value: PropTypes.string.isRequired,\n    children: PropTypes.any,\n    onPress: PropTypes.func\n  });\n  /*\n   * Copyright 2018 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n  /**\n   * Controls that are triggered by keyboard shortcuts.\n   */\n\n\n  var Controls = function Controls(props) {\n    var ai = null;\n\n    if (props.step) {\n      ai = [React.createElement(KeyboardShortcut, {\n        key: \"4\",\n        value: \"4\",\n        onPress: props.step\n      }, \"step\"), React.createElement(KeyboardShortcut, {\n        key: \"5\",\n        value: \"5\",\n        onPress: props.simulate\n      }, \"simulate\")];\n    }\n\n    var style = null;\n    var className = 'controls';\n\n    if (props.dockTop) {\n      className += ' docktop';\n    }\n\n    if (props.help) {\n      className += ' help';\n    }\n\n    var display = props.help && !props.dockTop ? 'block' : 'none';\n    return React.createElement(\"section\", {\n      id: \"debug-controls\",\n      style: style,\n      className: className\n    }, React.createElement(KeyboardShortcut, {\n      value: \"1\",\n      onPress: props.reset\n    }, \"reset\"), React.createElement(KeyboardShortcut, {\n      value: \"2\",\n      onPress: props.save\n    }, \"save\"), React.createElement(KeyboardShortcut, {\n      value: \"3\",\n      onPress: props.restore\n    }, \"restore\"), ai, props.dockTop || React.createElement(KeyboardShortcut, {\n      value: \"?\",\n      onPress: props.toggleHelp\n    }, \"show more\"), React.createElement(\"div\", {\n      className: \"key\",\n      style: {\n        display: display\n      }\n    }, React.createElement(\"div\", {\n      className: \"key-box\"\n    }, \"d\"), \" show/hide this pane\"), React.createElement(\"div\", {\n      className: \"key\",\n      style: {\n        display: display\n      }\n    }, React.createElement(\"div\", {\n      className: \"key-box\"\n    }, \"l\"), \" show/hide log\"), React.createElement(\"div\", {\n      className: \"key\",\n      style: {\n        display: display\n      }\n    }, React.createElement(\"div\", {\n      className: \"key-box\"\n    }, \"i\"), \" show/hide game info tab\"), React.createElement(\"div\", {\n      className: \"key\",\n      style: {\n        display: display\n      }\n    }, React.createElement(\"div\", {\n      className: \"key-box\"\n    }, \"t\"), \" dock controls\"));\n  };\n\n  Controls.propTypes = {\n    help: PropTypes.bool,\n    toggleHelp: PropTypes.func,\n    step: PropTypes.func,\n    simulate: PropTypes.func,\n    reset: PropTypes.func,\n    save: PropTypes.func,\n    restore: PropTypes.func,\n    dockTop: PropTypes.bool\n  };\n  /**\n   * Component that renders information about the\n   * players in the game (whose turn it is etc.).\n   */\n\n  var PlayerInfo =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(PlayerInfo, _React$Component);\n\n    function PlayerInfo() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      _classCallCheck(this, PlayerInfo);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PlayerInfo)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onClick\", function (playerID) {\n        var arg = playerID == _this.props.playerID ? null : playerID;\n\n        _this.props.onClick(arg);\n      });\n\n      return _this;\n    }\n\n    _createClass(PlayerInfo, [{\n      key: \"render\",\n      value: function render() {\n        var _this2 = this;\n\n        var players = [];\n\n        var _loop = function _loop(i) {\n          var playerID = i + '';\n          var className = 'player';\n\n          if (playerID === _this2.props.ctx.currentPlayer) {\n            className += ' current';\n          }\n\n          if (playerID === _this2.props.playerID) {\n            className += ' active';\n          }\n\n          players.push(React.createElement(\"div\", {\n            className: className,\n            key: i,\n            onClick: function onClick() {\n              return _this2.onClick(playerID);\n            }\n          }, playerID));\n        };\n\n        for (var i = 0; i < this.props.ctx.numPlayers; i++) {\n          _loop(i);\n        }\n\n        return React.createElement(\"div\", {\n          className: \"player-box\"\n        }, players);\n      }\n    }]);\n\n    return PlayerInfo;\n  }(React.Component);\n\n  _defineProperty(PlayerInfo, \"propTypes\", {\n    ctx: PropTypes.any.isRequired,\n    playerID: PropTypes.any,\n    onClick: PropTypes.func\n  });\n  /*\n   * Copyright 2018 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n\n  var DEV = process.env.NODE_ENV === 'development' || process.env.NODE_ENV == 'test';\n  var logfn = DEV ? console.log : function () {};\n  var errorfn = DEV ? console.error : function () {};\n\n  function error(error) {\n    errorfn('ERROR:', error);\n  }\n  /**\n   * DebugMove\n   *\n   * Component that allows the user to dispatch a move from\n   * the debug pane. The user is presented with the textarea\n   * to enter any additional arguments.\n   */\n\n\n  var DebugMove =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(DebugMove, _React$Component);\n\n    function DebugMove() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      _classCallCheck(this, DebugMove);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(DebugMove)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n        error: ''\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onSubmit\", function (value) {\n        var error$$1 = '';\n\n        try {\n          var argArray = new Function(\"return [\".concat(value, \"]\"))();\n\n          _this.props.fn.apply(_assertThisInitialized(_assertThisInitialized(_this)), argArray);\n        } catch (error2) {\n          error$$1 = '' + error2;\n          error(error2);\n        }\n\n        _this.setState({\n          error: error$$1,\n          focus: false,\n          enterArg: false\n        });\n      });\n\n      return _this;\n    }\n\n    _createClass(DebugMove, [{\n      key: \"render\",\n      value: function render() {\n        return React.createElement(\"div\", null, React.createElement(KeyboardShortcut, {\n          value: this.props.shortcut\n        }, React.createElement(DebugMoveArgField, {\n          name: this.props.name,\n          onSubmit: this.onSubmit\n        })), this.state.error ? React.createElement(\"span\", {\n          className: \"move-error\"\n        }, this.state.error) : null);\n      }\n    }]);\n\n    return DebugMove;\n  }(React.Component);\n\n  _defineProperty(DebugMove, \"propTypes\", {\n    name: PropTypes.string.isRequired,\n    shortcut: PropTypes.string.isRequired,\n    fn: PropTypes.func.isRequired\n  });\n\n  var DebugMoveArgField =\n  /*#__PURE__*/\n  function (_React$Component2) {\n    _inherits(DebugMoveArgField, _React$Component2);\n\n    function DebugMoveArgField() {\n      var _getPrototypeOf3;\n\n      var _this2;\n\n      _classCallCheck(this, DebugMoveArgField);\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(DebugMoveArgField)).call.apply(_getPrototypeOf3, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this2)), \"onKeyDown\", function (e) {\n        if (e.key == 'Enter') {\n          e.preventDefault();\n          var value = _this2.span.innerText;\n\n          _this2.props.onSubmit(value);\n\n          _this2.span.innerText = '';\n\n          _this2.props.deactivate();\n        }\n\n        if (e.key == 'Escape') {\n          e.preventDefault();\n\n          _this2.props.deactivate();\n        }\n      });\n\n      return _this2;\n    }\n\n    _createClass(DebugMoveArgField, [{\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate() {\n        if (this.props.active) {\n          this.span.focus();\n        } else {\n          this.span.blur();\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this3 = this;\n\n        var className = 'move';\n        if (this.props.active) className += ' active';\n        return React.createElement(\"div\", {\n          className: className,\n          onClick: this.props.activate\n        }, this.props.name, \"(\", React.createElement(\"span\", {\n          ref: function ref(r) {\n            _this3.span = r;\n          },\n          className: \"arg-field\",\n          onBlur: this.props.deactivate,\n          onKeyDown: this.onKeyDown,\n          contentEditable: true\n        }), \")\");\n      }\n    }]);\n\n    return DebugMoveArgField;\n  }(React.Component);\n\n  _defineProperty(DebugMoveArgField, \"propTypes\", {\n    name: PropTypes.string.isRequired,\n    onSubmit: PropTypes.func.isRequired,\n    active: PropTypes.bool,\n    activate: PropTypes.func,\n    deactivate: PropTypes.func\n  });\n  /*\n   * Copyright 2017 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n\n  var MAKE_MOVE = 'MAKE_MOVE';\n  var GAME_EVENT = 'GAME_EVENT';\n  var REDO = 'REDO';\n  var RESET = 'RESET';\n  var SYNC = 'SYNC';\n  var UNDO = 'UNDO';\n  var UPDATE = 'UPDATE';\n  var css$1 = \"/*\\n * Copyright 2017 The boardgame.io Authors\\n *\\n * Use of this source code is governed by a MIT-style\\n * license that can be found in the LICENSE file or at\\n * https://opensource.org/licenses/MIT.\\n */\\n\\n.gamelog {\\n  display: grid;\\n  grid-template-columns: 30px 1fr 30px;\\n  grid-auto-rows: auto;\\n  grid-auto-flow: column;\\n}\\n\\n.gamelog .turn-marker {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  grid-column: 1;\\n  background: #555;\\n  color: #eee;\\n  text-align: center;\\n  font-weight: bold;\\n  border: 1px solid #888;\\n}\\n\\n.gamelog .log-event {\\n  grid-column: 2;\\n  cursor: pointer;\\n  overflow: hidden;\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  background: #fff;\\n  border: 1px dotted #ccc;\\n  border-left: 5px solid #ccc;\\n  padding: 5px;\\n  text-align: center;\\n  color: #888;\\n  font-size: 14px;\\n  min-height: 25px;\\n  line-height: 25px;\\n}\\n\\n.gamelog .phase-marker {\\n  grid-column: 3;\\n  background: #555;\\n  border: 1px solid #888;\\n  color: #eee;\\n  text-align: center;\\n  font-weight: bold;\\n  padding-top: 10px;\\n  padding-bottom: 10px;\\n  text-orientation: sideways;\\n  writing-mode: vertical-rl;\\n  line-height: 30px;\\n  width: 100%;\\n}\\n\\n.gamelog.pinned .log-event {\\n  opacity: 0.2;\\n}\\n\\n.gamelog .log-event:hover {\\n  border-style: solid;\\n  background: #eee;\\n}\\n\\n.gamelog .log-event.pinned {\\n  border-style: solid;\\n  background: #eee;\\n  opacity: 1;\\n}\\n\\n.gamelog div.player0 {\\n  border-left-color: #ff851b;\\n}\\n\\n.gamelog div.player1 {\\n  border-left-color: #7fdbff;\\n}\\n\\n.gamelog div.player2 {\\n  border-left-color: #0074d9;\\n}\\n\\n.gamelog div.player3 {\\n  border-left-color: #39cccc;\\n}\\n\\n.gamelog div.player4 {\\n  border-left-color: #3d9970;\\n}\\n\\n.gamelog div.player5 {\\n  border-left-color: #2ecc40;\\n}\\n\\n.gamelog div.player6 {\\n  border-left-color: #01ff70;\\n}\\n\\n.gamelog div.player7 {\\n  border-left-color: #ffdc00;\\n}\\n\\n.gamelog div.player8 {\\n  border-left-color: #001f3f;\\n}\\n\\n.gamelog div.player9 {\\n  border-left-color: #ff4136;\\n}\\n\\n.gamelog div.player10 {\\n  border-left-color: #85144b;\\n}\\n\\n.gamelog div.player11 {\\n  border-left-color: #f012be;\\n}\\n\\n.gamelog div.player12 {\\n  border-left-color: #b10dc9;\\n}\\n\\n.gamelog div.player13 {\\n  border-left-color: #111111;\\n}\\n\\n.gamelog div.player14 {\\n  border-left-color: #aaaaaa;\\n}\\n\\n.gamelog div.player15 {\\n  border-left-color: #dddddd;\\n}\\n\";\n  styleInject(css$1);\n  /**\n   * Default component to render custom payload.\n   */\n\n  var CustomPayload = function CustomPayload(props) {\n    var custompayload = props.payload !== undefined ? JSON.stringify(props.payload, null, 4) : '';\n    return React.createElement(\"div\", null, custompayload);\n  };\n\n  CustomPayload.propTypes = {\n    payload: PropTypes.any\n  };\n  /**\n   * LogEvent\n   *\n   * Logs a single action in the game.\n   */\n\n  var LogEvent = function LogEvent(props) {\n    var action = props.action;\n    var args = action.payload.args || [];\n    var playerID = action.payload.playerID;\n    var classNames = \"log-event player\".concat(playerID);\n\n    if (props.pinned) {\n      classNames += ' pinned';\n    } // allow to pass in custom rendering component for custom payload\n\n\n    var customPayload = props.payloadComponent !== undefined ? React.createElement(props.payloadComponent, {\n      payload: props.payload\n    }) : React.createElement(CustomPayload, {\n      payload: props.payload\n    });\n    return React.createElement(\"div\", {\n      className: classNames,\n      onClick: function onClick() {\n        return props.onLogClick(props.logIndex);\n      },\n      onMouseEnter: function onMouseEnter() {\n        return props.onMouseEnter(props.logIndex);\n      },\n      onMouseLeave: function onMouseLeave() {\n        return props.onMouseLeave();\n      }\n    }, React.createElement(\"div\", null, action.payload.type, \"(\", args.join(','), \")\"), customPayload);\n  };\n\n  LogEvent.propTypes = {\n    action: PropTypes.any.isRequired,\n    logIndex: PropTypes.number.isRequired,\n    onLogClick: PropTypes.func.isRequired,\n    onMouseEnter: PropTypes.func.isRequired,\n    onMouseLeave: PropTypes.func.isRequired,\n    pinned: PropTypes.bool,\n    payload: PropTypes.object,\n    payloadComponent: PropTypes.oneOfType([PropTypes.element, PropTypes.func])\n  };\n  /**\n   * TurnMarker\n   *\n   * The markers on the left of the log events that indicate\n   * which turn the event belongs to.\n   */\n\n  var TurnMarker = function TurnMarker(props) {\n    return React.createElement(\"div\", {\n      className: \"turn-marker\",\n      style: {\n        gridRow: 'span ' + props.numEvents\n      }\n    }, props.turn);\n  };\n\n  TurnMarker.propTypes = {\n    turn: PropTypes.number.isRequired,\n    numEvents: PropTypes.number.isRequired\n  };\n  /**\n   * PhaseMarker\n   *\n   * The markers on the right of the log events that indicate\n   * which phase the event belongs to.\n   */\n\n  var PhaseMarker = function PhaseMarker(props) {\n    return React.createElement(\"div\", {\n      className: \"phase-marker\",\n      style: {\n        gridRow: 'span ' + props.numEvents\n      }\n    }, props.phase);\n  };\n\n  PhaseMarker.propTypes = {\n    phase: PropTypes.string.isRequired,\n    numEvents: PropTypes.number.isRequired\n  };\n  /**\n   * GameLog\n   *\n   * Component to log the actions in the game.\n   */\n\n  var GameLog =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(GameLog, _React$Component);\n\n    function GameLog() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      _classCallCheck(this, GameLog);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(GameLog)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n        pinned: null\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"rewind\", function (logIndex) {\n        var state = _this.props.initialState;\n\n        for (var i = 0; i < _this.props.log.length; i++) {\n          var action = _this.props.log[i].action;\n\n          if (!action.automatic) {\n            state = _this.props.reducer(state, action);\n          }\n\n          if (action.type == MAKE_MOVE) {\n            if (logIndex == 0) {\n              break;\n            }\n\n            logIndex--;\n          }\n        }\n\n        return {\n          G: state.G,\n          ctx: state.ctx\n        };\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onLogClick\", function (logIndex) {\n        _this.setState(function (o) {\n          var state = _this.rewind(logIndex);\n\n          var renderedLogEntries = _this.props.log.filter(function (e) {\n            return e.action.type == MAKE_MOVE;\n          });\n\n          var metadata = renderedLogEntries[logIndex].action.payload.metadata;\n\n          if (o.pinned === logIndex) {\n            _this.props.onHover({\n              logIndex: logIndex,\n              state: state,\n              metadata: undefined\n            });\n\n            return {\n              pinned: null\n            };\n          }\n\n          _this.props.onHover({\n            logIndex: logIndex,\n            state: state,\n            metadata: metadata\n          });\n\n          return {\n            pinned: logIndex\n          };\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onMouseEnter\", function (logIndex) {\n        if (_this.state.pinned === null) {\n          var state = _this.rewind(logIndex);\n\n          _this.props.onHover({\n            logIndex: logIndex,\n            state: state\n          });\n        }\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onMouseLeave\", function () {\n        if (_this.state.pinned === null) {\n          _this.props.onHover({\n            state: null\n          });\n        }\n      });\n\n      return _this;\n    }\n\n    _createClass(GameLog, [{\n      key: \"render\",\n      value: function render() {\n        var log = [];\n        var turns = [];\n        var phases = [];\n        var eventsInCurrentPhase = 0;\n        var eventsInCurrentTurn = 0;\n        var renderedLogEntries = this.props.log.filter(function (e) {\n          return e.action.type == MAKE_MOVE;\n        });\n\n        for (var i = 0; i < renderedLogEntries.length; i++) {\n          var _renderedLogEntries$i = renderedLogEntries[i],\n              action = _renderedLogEntries$i.action,\n              payload = _renderedLogEntries$i.payload,\n              turn = _renderedLogEntries$i.turn,\n              phase = _renderedLogEntries$i.phase;\n          eventsInCurrentPhase++;\n          eventsInCurrentTurn++;\n          log.push(React.createElement(LogEvent, {\n            key: i,\n            pinned: i === this.state.pinned,\n            logIndex: i,\n            onLogClick: this.onLogClick,\n            onMouseEnter: this.onMouseEnter,\n            onMouseLeave: this.onMouseLeave,\n            action: action,\n            payload: payload,\n            payloadComponent: this.props.payloadComponent\n          }));\n\n          if (i == renderedLogEntries.length - 1 || renderedLogEntries[i + 1].turn != turn) {\n            turns.push(React.createElement(TurnMarker, {\n              key: turns.length,\n              turn: turn,\n              numEvents: eventsInCurrentTurn\n            }));\n            eventsInCurrentTurn = 0;\n          }\n\n          if (i == renderedLogEntries.length - 1 || renderedLogEntries[i + 1].phase != phase) {\n            phases.push(React.createElement(PhaseMarker, {\n              key: phases.length,\n              phase: phase,\n              numEvents: eventsInCurrentPhase\n            }));\n            eventsInCurrentPhase = 0;\n          }\n        }\n\n        var className = 'gamelog';\n\n        if (this.state.pinned !== null) {\n          className += ' pinned';\n        }\n\n        return React.createElement(\"div\", {\n          className: className\n        }, turns, log, phases);\n      }\n    }]);\n\n    return GameLog;\n  }(React.Component);\n\n  _defineProperty(GameLog, \"propTypes\", {\n    onHover: PropTypes.func,\n    reducer: PropTypes.func,\n    initialState: PropTypes.any.isRequired,\n    log: PropTypes.array.isRequired,\n    payloadComponent: PropTypes.oneOfType([PropTypes.element, PropTypes.func])\n  });\n\n  _defineProperty(GameLog, \"defaultProps\", {\n    onHover: function onHover() {}\n  });\n  /*\n   * Copyright 2017 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n  /**\n   * Generate a move to be dispatched to the game move reducer.\n   *\n   * @param {string} type - The move type.\n   * @param {Array}  args - Additional arguments.\n   * @param {string}  playerID - The ID of the player making this action.\n   * @param {string}  credentials - (optional) The credentials for the player making this action.\n   */\n\n\n  var makeMove = function makeMove(type, args, playerID, credentials) {\n    return {\n      type: MAKE_MOVE,\n      payload: {\n        type: type,\n        args: args,\n        playerID: playerID,\n        credentials: credentials\n      }\n    };\n  };\n  /**\n   * Generate a game event to be dispatched to the flow reducer.\n   *\n   * @param {string} type - The event type.\n   * @param {Array}  args - Additional arguments.\n   * @param {string}  playerID - The ID of the player making this action.\n   * @param {string}  credentials - (optional) The credentials for the player making this action.\n   */\n\n\n  var gameEvent = function gameEvent(type, args, playerID, credentials) {\n    return {\n      type: GAME_EVENT,\n      payload: {\n        type: type,\n        args: args,\n        playerID: playerID,\n        credentials: credentials\n      }\n    };\n  };\n  /**\n   * Generate an automatic game event that is a side-effect of a move.\n   * @param {string} type - The event type.\n   * @param {Array}  args - Additional arguments.\n   * @param {string}  playerID - The ID of the player making this action.\n   * @param {string}  credentials - (optional) The credentials for the player making this action.\n   */\n\n\n  var automaticGameEvent = function automaticGameEvent(type, args, playerID, credentials) {\n    return {\n      type: GAME_EVENT,\n      payload: {\n        type: type,\n        args: args,\n        playerID: playerID,\n        credentials: credentials\n      },\n      automatic: true\n    };\n  };\n  /**\n   * Used to reset the Redux store's state on a sync.\n   * @param {object} state - The state to restore.\n   * @param {Array} log - The log to restore.\n   */\n\n\n  var sync = function sync(state, log) {\n    return {\n      type: SYNC,\n      state: state,\n      log: log,\n      clientOnly: true\n    };\n  };\n  /**\n   * Used to update the Redux store's state in response to\n   * an action coming from another player.\n   * @param {object} state - The state to restore.\n   * @param {Array} deltalog - A log delta.\n   */\n\n\n  var update = function update(state, deltalog) {\n    return {\n      type: UPDATE,\n      state: state,\n      deltalog: deltalog,\n      clientOnly: true\n    };\n  };\n  /**\n   * Used to reset the game state.\n   * @param {object} state - The initial state.\n   */\n\n\n  var reset = function reset(state) {\n    return {\n      type: RESET,\n      state: state,\n      clientOnly: true\n    };\n  };\n  /**\n   * Used to undo the last move.\n   */\n\n\n  var undo = function undo() {\n    return {\n      type: UNDO\n    };\n  };\n  /**\n   * Used to redo the last undone move.\n   */\n\n\n  var redo = function redo() {\n    return {\n      type: REDO\n    };\n  };\n\n  var ActionCreators =\n  /*#__PURE__*/\n  Object.freeze({\n    makeMove: makeMove,\n    gameEvent: gameEvent,\n    automaticGameEvent: automaticGameEvent,\n    sync: sync,\n    update: update,\n    reset: reset,\n    undo: undo,\n    redo: redo\n  });\n  /**\n   * Removes all the keys in ctx that begin with a _.\n   */\n\n  function SanitizeCtx(ctx) {\n    var r = {};\n\n    for (var key in ctx) {\n      if (!key.startsWith('_')) {\n        r[key] = ctx[key];\n      }\n    }\n\n    return r;\n  }\n  /**\n   * Debug\n   *\n   * Debug pane that displays the game state objects,\n   * allows you to dispatch moves,\n   * and allows you to save / restore from localStorage.\n   */\n\n\n  var Debug =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(Debug, _React$Component);\n\n    function Debug(props) {\n      var _this;\n\n      _classCallCheck(this, Debug);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Debug).call(this, props));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"saveState\", function () {\n        var json = flatted.stringify(_this.props.gamestate);\n        window.localStorage.setItem('gamestate', json);\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"restoreState\", function () {\n        var gamestateJSON = window.localStorage.getItem('gamestate');\n\n        if (gamestateJSON !== null) {\n          var gamestate = flatted.parse(gamestateJSON);\n\n          _this.props.store.dispatch(sync(gamestate));\n        }\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onClickMain\", function () {\n        _this.setState({\n          showLog: false\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onClickLog\", function () {\n        _this.setState({\n          showLog: true\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"toggleHelp\", function () {\n        _this.setState(function (oldstate) {\n          return {\n            help: !oldstate.help\n          };\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onLogHover\", function (_ref) {\n        var state = _ref.state,\n            metadata = _ref.metadata;\n\n        _this.setState({\n          AIMetadata: metadata\n        });\n\n        _this.props.overrideGameState(state);\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"simulate\", function () {\n        var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10000;\n        var sleepTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n\n        var step = async function step() {\n          for (var i = 0; i < iterations; i++) {\n            var action = await _this.props.step();\n            if (!action) break;\n            await new Promise(function (resolve) {\n              return setTimeout(resolve, sleepTimeout);\n            });\n          }\n        };\n\n        return step();\n      });\n\n      _this.shortcuts = AssignShortcuts(props.moves, props.events, 'dlit');\n      _this.state = {\n        showDebugUI: true,\n        showLog: false,\n        showGameInfo: props.showGameInfo,\n        dockControls: props.dockControls,\n        help: false,\n        AIMetadata: null\n      };\n      return _this;\n    }\n\n    _createClass(Debug, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        Mousetrap.bind('d', function (e) {\n          e.preventDefault();\n\n          _this2.setState(function (old) {\n            return {\n              showDebugUI: !old.showDebugUI\n            };\n          });\n        });\n        Mousetrap.bind('l', function (e) {\n          e.preventDefault();\n\n          _this2.setState(function (old) {\n            return {\n              showLog: !old.showLog\n            };\n          });\n        });\n        Mousetrap.bind('i', function (e) {\n          e.preventDefault();\n\n          _this2.setState(function (old) {\n            return {\n              showGameInfo: !old.showGameInfo\n            };\n          });\n        });\n        Mousetrap.bind('t', function (e) {\n          e.preventDefault();\n\n          _this2.setState(function (old) {\n            return {\n              dockControls: !old.dockControls\n            };\n          });\n        });\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        Mousetrap.unbind('d');\n        Mousetrap.unbind('l');\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        if (!this.state.showDebugUI) {\n          return null;\n        }\n\n        var moves = [];\n\n        for (var name in this.props.moves) {\n          var fn = this.props.moves[name];\n          var shortcut = this.shortcuts[name];\n          moves.push(React.createElement(DebugMove, {\n            key: name,\n            name: name,\n            fn: fn,\n            shortcut: shortcut\n          }));\n        }\n\n        var events = [];\n\n        for (var _name in this.props.events) {\n          var _fn = this.props.events[_name];\n          var _shortcut = this.shortcuts[_name];\n          events.push(React.createElement(DebugMove, {\n            key: _name,\n            name: _name,\n            fn: _fn,\n            shortcut: _shortcut\n          }));\n        }\n\n        var visualizeAI = this.state.AIMetadata && this.props.visualizeAI;\n        var className = 'debug-ui';\n\n        if (this.state.dockControls) {\n          className += ' docktop';\n        }\n\n        return React.createElement(\"div\", {\n          className: className\n        }, visualizeAI && React.createElement(\"div\", {\n          className: \"ai-visualization\"\n        }, this.props.visualizeAI(this.state.AIMetadata)), React.createElement(\"div\", {\n          className: \"pane\"\n        }, React.createElement(\"div\", {\n          className: \"menu\"\n        }, React.createElement(\"div\", {\n          className: this.state.showLog ? 'item' : 'item active',\n          onClick: this.onClickMain\n        }, \"Main\"), React.createElement(\"div\", {\n          className: this.state.showLog ? 'item active' : 'item',\n          onClick: this.onClickLog\n        }, \"Log\")), this.state.showLog || React.createElement(\"span\", null, this.state.showGameInfo && React.createElement(GameInfo, {\n          gameID: this.props.gameID,\n          playerID: this.props.playerID,\n          isActive: this.props.gamestate.isActive,\n          isConnected: this.props.gamestate.isConnected,\n          isMultiplayer: this.props.isMultiplayer\n        }), React.createElement(Controls, {\n          dockTop: this.state.dockControls,\n          help: this.state.help,\n          toggleHelp: this.toggleHelp,\n          step: this.props.step,\n          simulate: this.simulate,\n          reset: this.props.reset,\n          save: this.saveState,\n          restore: this.restoreState\n        }), React.createElement(\"h3\", null, \"Players\"), React.createElement(PlayerInfo, {\n          ctx: this.props.gamestate.ctx,\n          playerID: this.props.playerID,\n          onClick: this.props.updatePlayerID\n        }), React.createElement(\"h3\", null, \"Moves\"), React.createElement(\"section\", null, moves), React.createElement(\"h3\", null, \"Events\"), React.createElement(\"section\", null, events), React.createElement(\"section\", null, React.createElement(\"pre\", {\n          className: \"json\"\n        }, React.createElement(\"strong\", null, \"G\"), \":\", ' ', JSON.stringify(this.props.gamestate.G, null, 2))), React.createElement(\"section\", null, React.createElement(\"pre\", {\n          className: \"json\"\n        }, React.createElement(\"strong\", null, \"ctx\"), \":\", ' ', JSON.stringify(SanitizeCtx(this.props.gamestate.ctx), null, 2)))), this.state.showLog && React.createElement(\"section\", null, React.createElement(GameLog, {\n          onHover: this.onLogHover,\n          reducer: this.props.reducer,\n          log: this.props.gamestate.log,\n          initialState: this.props.gamestate._initial\n        }))));\n      }\n    }]);\n\n    return Debug;\n  }(React.Component);\n\n  _defineProperty(Debug, \"propTypes\", {\n    gamestate: PropTypes.shape({\n      G: PropTypes.any.isRequired,\n      ctx: PropTypes.any.isRequired,\n      log: PropTypes.array.isRequired,\n      isActive: PropTypes.bool,\n      isConnected: PropTypes.bool,\n      _initial: PropTypes.any.isRequired\n    }),\n    gameID: PropTypes.string.isRequired,\n    playerID: PropTypes.string,\n    isMultiplayer: PropTypes.bool,\n    moves: PropTypes.any,\n    events: PropTypes.any,\n    restore: PropTypes.func,\n    showLog: PropTypes.bool,\n    store: PropTypes.any,\n    step: PropTypes.func,\n    reset: PropTypes.func,\n    reducer: PropTypes.func,\n    overrideGameState: PropTypes.func,\n    visualizeAI: PropTypes.func,\n    updateGameID: PropTypes.func,\n    updatePlayerID: PropTypes.func,\n    updateCredentials: PropTypes.func,\n    showGameInfo: PropTypes.bool,\n    dockControls: PropTypes.bool\n  });\n\n  _defineProperty(Debug, \"defaultProps\", {\n    showGameInfo: true,\n    dockControls: false\n  });\n  /**\n   * SocketIO\n   *\n   * Transport interface that interacts with the Master via socket.io.\n   */\n\n\n  var SocketIO =\n  /*#__PURE__*/\n  function () {\n    /**\n     * Creates a new Mutiplayer instance.\n     * @param {object} socket - Override for unit tests.\n     * @param {object} socketOpts - Options to pass to socket.io.\n     * @param {string} gameID - The game ID to connect to.\n     * @param {string} playerID - The player ID associated with this client.\n     * @param {string} gameName - The game type (the `name` field in `Game`).\n     * @param {string} numPlayers - The number of players.\n     * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.\n     */\n    function SocketIO() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          socket = _ref.socket,\n          socketOpts = _ref.socketOpts,\n          store = _ref.store,\n          gameID = _ref.gameID,\n          playerID = _ref.playerID,\n          gameName = _ref.gameName,\n          numPlayers = _ref.numPlayers,\n          server = _ref.server;\n\n      _classCallCheck(this, SocketIO);\n\n      this.server = server;\n      this.socket = socket;\n      this.store = store;\n      this.socketOpts = socketOpts;\n      this.gameName = gameName || 'default';\n      this.gameID = gameID || 'default';\n      this.playerID = playerID || null;\n      this.numPlayers = numPlayers || 2;\n      this.gameID = this.gameName + ':' + this.gameID;\n      this.isConnected = false;\n\n      this.callback = function () {};\n    }\n    /**\n     * Called when an action that has to be relayed to the\n     * game master is made.\n     */\n\n\n    _createClass(SocketIO, [{\n      key: \"onAction\",\n      value: function onAction(state, action) {\n        this.socket.emit('update', action, state._stateID, this.gameID, this.playerID);\n      }\n      /**\n       * Connect to the server.\n       */\n\n    }, {\n      key: \"connect\",\n      value: function connect() {\n        var _this = this;\n\n        if (!this.socket) {\n          if (this.server) {\n            var server = this.server;\n\n            if (server.search(/^https?:\\/\\//) == -1) {\n              server = 'http://' + this.server;\n            }\n\n            if (server.substr(-1) != '/') {\n              // add trailing slash if not already present\n              server = server + '/';\n            }\n\n            this.socket = io(server + this.gameName, this.socketOpts);\n          } else {\n            this.socket = io('/' + this.gameName, this.socketOpts);\n          }\n        } // Called when another player makes a move and the\n        // master broadcasts the update to other clients (including\n        // this one).\n\n\n        this.socket.on('update', function (gameID, state, deltalog) {\n          var currentState = _this.store.getState();\n\n          if (gameID == _this.gameID && state._stateID >= currentState._stateID) {\n            var action = update(state, deltalog);\n\n            _this.store.dispatch(action);\n          }\n        }); // Called when the client first connects to the master\n        // and requests the current game state.\n\n        this.socket.on('sync', function (gameID, state, log) {\n          if (gameID == _this.gameID) {\n            var action = sync(state, log);\n\n            _this.store.dispatch(action);\n          }\n        }); // Initial sync to get game state.\n\n        this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers); // Keep track of connection status.\n\n        this.socket.on('connect', function () {\n          _this.isConnected = true;\n\n          _this.callback();\n        });\n        this.socket.on('disconnect', function () {\n          _this.isConnected = false;\n\n          _this.callback();\n        });\n      }\n      /**\n       * Subscribe to connection state changes.\n       */\n\n    }, {\n      key: \"subscribe\",\n      value: function subscribe(fn) {\n        this.callback = fn;\n      }\n      /**\n       * Updates the game id.\n       * @param {string} id - The new game id.\n       */\n\n    }, {\n      key: \"updateGameID\",\n      value: function updateGameID(id) {\n        this.gameID = this.gameName + ':' + id;\n        var action = reset(null);\n        this.store.dispatch(action);\n\n        if (this.socket) {\n          this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);\n        }\n      }\n      /**\n       * Updates the player associated with this client.\n       * @param {string} id - The new player id.\n       */\n\n    }, {\n      key: \"updatePlayerID\",\n      value: function updatePlayerID(id) {\n        this.playerID = id;\n        var action = reset(null);\n        this.store.dispatch(action);\n\n        if (this.socket) {\n          this.socket.emit('sync', this.gameID, this.playerID, this.numPlayers);\n        }\n      }\n    }]);\n\n    return SocketIO;\n  }();\n  /*\n   * Copyright 2017 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n  /**\n   * InMemory data storage.\n   */\n\n\n  var InMemory =\n  /*#__PURE__*/\n  function () {\n    /**\n     * Creates a new InMemory storage.\n     */\n    function InMemory() {\n      _classCallCheck(this, InMemory);\n\n      this.games = new Map();\n    }\n    /**\n     * Connect.\n     * No-op for the InMemory instance.\n     */\n\n\n    _createClass(InMemory, [{\n      key: \"connect\",\n      value: function connect() {\n        return;\n      }\n      /**\n       * Write the game state to the in-memory object.\n       * @param {string} id - The game id.\n       * @param {object} store - A game state to persist.\n       */\n\n    }, {\n      key: \"set\",\n      value: function set(id, state) {\n        return this.games.set(id, state);\n      }\n      /**\n       * Read the game state from the in-memory object.\n       * @param {string} id - The game id.\n       * @returns {object} - A game state, or undefined\n       *                     if no game is found with this id.\n       */\n\n    }, {\n      key: \"get\",\n      value: function get(id) {\n        return this.games.get(id);\n      }\n      /**\n       * Check if a particular game id exists.\n       * @param {string} id - The game id.\n       * @returns {boolean} - True if a game with this id exists.\n       */\n\n    }, {\n      key: \"has\",\n      value: function has(id) {\n        return this.games.has(id);\n      }\n      /**\n       * Remove the game state from the in-memory object.\n       * @param {string} id - The game id.\n       */\n\n    }, {\n      key: \"remove\",\n      value: function remove(id) {\n        if (!this.games.has(id)) return;\n        this.games.delete(id);\n      }\n      /**\n       * Return all keys.\n       * @returns {array} - Array of keys (strings)\n       */\n\n    }, {\n      key: \"list\",\n      value: function list() {\n        return _toConsumableArray(this.games.keys());\n      }\n    }]);\n\n    return InMemory;\n  }(); // Inlined version of Alea from https://github.com/davidbau/seedrandom.\n\n  /*\n   * Copyright 2015 David Bau.\n   *\n   * Permission is hereby granted, free of charge,\n   * to any person obtaining a copy of this software\n   * and associated documentation files (the \"Software\"),\n   * to deal in the Software without restriction, including\n   * without limitation the rights to use, copy, modify, merge,\n   * publish, distribute, sublicense, and/or sell copies of the\n   * Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall\n   * be included in all copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n   * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n   * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n   * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n   * DEALINGS IN THE SOFTWARE.\n   */\n\n\n  function Alea(seed) {\n    var me = this,\n        mash = Mash();\n\n    me.next = function () {\n      var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32\n\n      me.s0 = me.s1;\n      me.s1 = me.s2;\n      return me.s2 = t - (me.c = t | 0);\n    }; // Apply the seeding algorithm from Baagoe.\n\n\n    me.c = 1;\n    me.s0 = mash(' ');\n    me.s1 = mash(' ');\n    me.s2 = mash(' ');\n    me.s0 -= mash(seed);\n\n    if (me.s0 < 0) {\n      me.s0 += 1;\n    }\n\n    me.s1 -= mash(seed);\n\n    if (me.s1 < 0) {\n      me.s1 += 1;\n    }\n\n    me.s2 -= mash(seed);\n\n    if (me.s2 < 0) {\n      me.s2 += 1;\n    }\n\n    mash = null;\n  }\n\n  function copy(f, t) {\n    t.c = f.c;\n    t.s0 = f.s0;\n    t.s1 = f.s1;\n    t.s2 = f.s2;\n    return t;\n  }\n\n  function Mash() {\n    var n = 0xefc8249d;\n\n    var mash = function mash(data) {\n      data = data.toString();\n\n      for (var i = 0; i < data.length; i++) {\n        n += data.charCodeAt(i);\n        var h = 0.02519603282416938 * n;\n        n = h >>> 0;\n        h -= n;\n        h *= n;\n        n = h >>> 0;\n        h -= n;\n        n += h * 0x100000000; // 2^32\n      }\n\n      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n    };\n\n    return mash;\n  }\n\n  function alea(seed, opts) {\n    var xg = new Alea(seed),\n        state = opts && opts.state,\n        prng = xg.next;\n    prng.quick = prng;\n\n    if (state) {\n      if (_typeof(state) == 'object') copy(state, xg);\n\n      prng.state = function () {\n        return copy(xg, {});\n      };\n    }\n\n    return prng;\n  }\n  /**\n   * Random\n   *\n   * Calls that require a pseudorandom number generator.\n   * Uses a seed from ctx, and also persists the PRNG\n   * state in ctx so that moves can stay pure.\n   */\n\n\n  var Random =\n  /*#__PURE__*/\n  function () {\n    /**\n     * constructor\n     * @param {object} ctx - The ctx object to initialize from.\n     */\n    function Random(ctx) {\n      _classCallCheck(this, Random); // If we are on the client, the seed is not present.\n      // Just use a temporary seed to execute the move without\n      // crashing it. The move state itself is discarded,\n      // so the actual value doesn't matter.\n\n\n      this.state = ctx._random || {\n        seed: '0'\n      };\n    }\n    /**\n     * Updates ctx with the PRNG state.\n     * @param {object} ctx - The ctx object to update.\n     */\n\n\n    _createClass(Random, [{\n      key: \"update\",\n      value: function update(state) {\n        var ctx = _objectSpread({}, state.ctx, {\n          _random: this.state\n        });\n\n        return _objectSpread({}, state, {\n          ctx: ctx\n        });\n      }\n      /**\n       * Attaches the Random API to ctx.\n       * @param {object} ctx - The ctx object to attach to.\n       */\n\n    }, {\n      key: \"attach\",\n      value: function attach(ctx) {\n        return _objectSpread({}, ctx, {\n          random: this._api()\n        });\n      }\n      /**\n       * Generate a random number.\n       */\n\n    }, {\n      key: \"_random\",\n      value: function _random() {\n        var R = this.state;\n        var fn;\n\n        if (R.prngstate === undefined) {\n          // No call to a random function has been made.\n          fn = new alea(R.seed, {\n            state: true\n          });\n        } else {\n          fn = new alea('', {\n            state: R.prngstate\n          });\n        }\n\n        var number = fn();\n        this.state = _objectSpread({}, R, {\n          prngstate: fn.state()\n        });\n        return number;\n      }\n    }, {\n      key: \"_api\",\n      value: function _api() {\n        var random = this._random.bind(this);\n\n        var SpotValue = {\n          D4: 4,\n          D6: 6,\n          D8: 8,\n          D10: 10,\n          D12: 12,\n          D20: 20\n        }; // Generate functions for predefined dice values D4 - D20.\n\n        var predefined = {};\n\n        var _loop = function _loop(key) {\n          var spotvalue = SpotValue[key];\n\n          predefined[key] = function (diceCount) {\n            if (diceCount === undefined) {\n              return Math.floor(random() * spotvalue) + 1;\n            } else {\n              return _toConsumableArray(new Array(diceCount).keys()).map(function () {\n                return Math.floor(random() * spotvalue) + 1;\n              });\n            }\n          };\n        };\n\n        for (var key in SpotValue) {\n          _loop(key);\n        }\n\n        return _objectSpread({}, predefined, {\n          /**\n           * Roll a die of specified spot value.\n           *\n           * @param {number} spotvalue - The die dimension (default: 6).\n           * @param {number} diceCount - number of dice to throw.\n           *                             if not defined, defaults to 1 and returns the value directly.\n           *                             if defined, returns an array containing the random dice values.\n           */\n          Die: function Die(spotvalue, diceCount) {\n            if (spotvalue === undefined) {\n              spotvalue = 6;\n            }\n\n            if (diceCount === undefined) {\n              return Math.floor(random() * spotvalue) + 1;\n            } else {\n              return _toConsumableArray(new Array(diceCount).keys()).map(function () {\n                return Math.floor(random() * spotvalue) + 1;\n              });\n            }\n          },\n\n          /**\n           * Generate a random number between 0 and 1.\n           */\n          Number: function Number() {\n            return random();\n          },\n\n          /**\n           * Shuffle an array.\n           *\n           * @param {Array} deck - The array to shuffle. Does not mutate\n           *                       the input, but returns the shuffled array.\n           */\n          Shuffle: function Shuffle(deck) {\n            var clone = deck.slice(0);\n            var srcIndex = deck.length;\n            var dstIndex = 0;\n            var shuffled = new Array(srcIndex);\n\n            while (srcIndex) {\n              var randIndex = srcIndex * random() | 0;\n              shuffled[dstIndex++] = clone[randIndex];\n              clone[randIndex] = clone[--srcIndex];\n            }\n\n            return shuffled;\n          }\n        });\n      }\n    }]);\n\n    return Random;\n  }();\n  /**\n   * Removes the attached Random api from ctx.\n   *\n   * @param {object} ctx - The ctx object with the Random API attached.\n   * @returns {object} A plain ctx object without the Random API.\n   */\n\n\n  Random.detach = function (ctx) {\n    var random = ctx.random,\n        rest = _objectWithoutProperties(ctx, [\"random\"]); // eslint-disable-line no-unused-vars\n\n\n    return rest;\n  };\n  /**\n   * Generates a new seed from the current date / time.\n   */\n\n\n  Random.seed = function () {\n    return (+new Date()).toString(36).slice(-10);\n  };\n  /**\n   * Events\n   */\n\n\n  var Events =\n  /*#__PURE__*/\n  function () {\n    function Events(flow, playerID) {\n      _classCallCheck(this, Events);\n\n      this.flow = flow;\n      this.playerID = playerID;\n      this.dispatch = [];\n    }\n    /**\n     * Attaches the Events API to ctx.\n     * @param {object} ctx - The ctx object to attach to.\n     */\n\n\n    _createClass(Events, [{\n      key: \"attach\",\n      value: function attach(ctx) {\n        var _this = this;\n\n        var events = {};\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          var _loop = function _loop() {\n            var key = _step.value;\n\n            events[key] = function () {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              _this.dispatch.push({\n                key: key,\n                args: args\n              });\n            };\n          };\n\n          for (var _iterator = this.flow.eventNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            _loop();\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return _objectSpread({}, ctx, {\n          events: events\n        });\n      }\n      /**\n       * Updates ctx with the triggered events.\n       * @param {object} state - The state object { G, ctx }.\n       */\n\n    }, {\n      key: \"update\",\n      value: function update$$1(state) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.dispatch[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var item = _step2.value;\n            var action = automaticGameEvent(item.key, item.args, this.playerID);\n            state = _objectSpread({}, state, this.flow.processGameEvent(state, action));\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return state;\n      }\n    }]);\n\n    return Events;\n  }();\n  /**\n   * Detaches the Events API from ctx.\n   * @param {object} ctx - The ctx object to strip.\n   */\n\n\n  Events.detach = function (ctx) {\n    var events = ctx.events,\n        rest = _objectWithoutProperties(ctx, [\"events\"]); // eslint-disable-line no-unused-vars\n\n\n    return rest;\n  };\n  /*\n   * Copyright 2018 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n  /**\n   * Plugin that allows using Immer to make immutable changes\n   * to G by just mutating it.\n   */\n\n\n  var PluginImmer = {\n    fnWrap: function fnWrap(move) {\n      return produce(move);\n    }\n  };\n  /**\n   * List of plugins that are always added.\n   */\n\n  var DEFAULT_PLUGINS = [PluginImmer];\n  var G = {\n    /**\n     * Applies the provided plugins to G during game setup.\n     *\n     * @param {object} G - The G object.\n     * @param {object} ctx - The ctx object.\n     * @param {object} game - The game object.\n     */\n    setup: function setup(G, ctx, game) {\n      [].concat(DEFAULT_PLUGINS, _toConsumableArray(game.plugins)).filter(function (plugin) {\n        return plugin.G !== undefined;\n      }).filter(function (plugin) {\n        return plugin.G.setup !== undefined;\n      }).forEach(function (plugin) {\n        G = plugin.G.setup(G, ctx, game);\n      });\n      return G;\n    },\n\n    /**\n     * Applies the provided plugins to G during the beginning of the phase.\n     *\n     * @param {object} G - The G object.\n     * @param {object} ctx - The ctx object.\n     * @param {object} game - The game object.\n     */\n    onPhaseBegin: function onPhaseBegin(G, ctx, game) {\n      [].concat(DEFAULT_PLUGINS, _toConsumableArray(game.plugins)).filter(function (plugin) {\n        return plugin.G !== undefined;\n      }).filter(function (plugin) {\n        return plugin.G.onPhaseBegin !== undefined;\n      }).forEach(function (plugin) {\n        G = plugin.G.onPhaseBegin(G, ctx, game);\n      });\n      return G;\n    }\n  };\n  var ctx = {\n    /**\n     * Applies the provided plugins to ctx during game setup.\n     *\n     * @param {object} ctx - The ctx object.\n     * @param {object} game - The game object.\n     */\n    setup: function setup(ctx, game) {\n      [].concat(DEFAULT_PLUGINS, _toConsumableArray(game.plugins)).filter(function (plugin) {\n        return plugin.ctx !== undefined;\n      }).filter(function (plugin) {\n        return plugin.ctx.setup !== undefined;\n      }).forEach(function (plugin) {\n        ctx = plugin.ctx.setup(ctx, game);\n      });\n      return ctx;\n    },\n\n    /**\n     * Applies the provided plugins to ctx during the beginning of the phase.\n     *\n     * @param {object} ctx - The ctx object.\n     * @param {object} game - The game object.\n     */\n    onPhaseBegin: function onPhaseBegin(ctx, game) {\n      [].concat(DEFAULT_PLUGINS, _toConsumableArray(game.plugins)).filter(function (plugin) {\n        return plugin.ctx !== undefined;\n      }).filter(function (plugin) {\n        return plugin.ctx.onPhaseBegin !== undefined;\n      }).forEach(function (plugin) {\n        ctx = plugin.ctx.onPhaseBegin(ctx, game);\n      });\n      return ctx;\n    }\n  };\n  /**\n   * Moves can return this when they want to indicate\n   * that the combination of arguments is illegal and\n   * the move ought to be discarded.\n   */\n\n  var INVALID_MOVE = 'INVALID_MOVE';\n  /**\n   * Context API to allow writing custom logs in games.\n   */\n\n  var GameLoggerCtxAPI =\n  /*#__PURE__*/\n  function () {\n    function GameLoggerCtxAPI() {\n      _classCallCheck(this, GameLoggerCtxAPI);\n\n      this._payload = undefined;\n    }\n\n    _createClass(GameLoggerCtxAPI, [{\n      key: \"_api\",\n      value: function _api() {\n        var _this = this;\n\n        return {\n          setPayload: function setPayload(payload) {\n            _this._payload = payload;\n          }\n        };\n      }\n    }, {\n      key: \"attach\",\n      value: function attach(ctx$$1) {\n        return _objectSpread({}, ctx$$1, {\n          log: this._api()\n        });\n      }\n    }, {\n      key: \"update\",\n      value: function update(state) {\n        if (this._payload === undefined) {\n          return state;\n        } // attach the payload to the last log event\n\n\n        var deltalog = state.deltalog;\n        deltalog[deltalog.length - 1] = _objectSpread({}, deltalog[deltalog.length - 1], {\n          payload: this._payload\n        });\n        this._payload = undefined;\n        return _objectSpread({}, state, {\n          deltalog: deltalog\n        });\n      }\n    }], [{\n      key: \"detach\",\n      value: function detach(ctx$$1) {\n        var log = ctx$$1.log,\n            ctxWithoutLog = _objectWithoutProperties(ctx$$1, [\"log\"]); // eslint-disable-line no-unused-vars\n\n\n        return ctxWithoutLog;\n      }\n    }]);\n\n    return GameLoggerCtxAPI;\n  }();\n  /**\n   * This class is used to attach/detach various utility objects\n   * onto a ctx, without having to manually attach/detach them\n   * all separately.\n   */\n\n\n  var ContextEnhancer =\n  /*#__PURE__*/\n  function () {\n    function ContextEnhancer(ctx$$1, game, player) {\n      _classCallCheck(this, ContextEnhancer);\n\n      this.random = new Random(ctx$$1);\n      this.events = new Events(game.flow, player);\n      this.log = new GameLoggerCtxAPI();\n    }\n\n    _createClass(ContextEnhancer, [{\n      key: \"attachToContext\",\n      value: function attachToContext(ctx$$1) {\n        var ctxWithAPI = this.random.attach(ctx$$1);\n        ctxWithAPI = this.events.attach(ctxWithAPI);\n        ctxWithAPI = this.log.attach(ctxWithAPI);\n        return ctxWithAPI;\n      }\n    }, {\n      key: \"_update\",\n      value: function _update(state, updateEvents) {\n        var newState = updateEvents ? this.events.update(state) : state;\n        newState = this.random.update(newState);\n        newState = this.log.update(newState);\n        return newState;\n      }\n    }, {\n      key: \"updateAndDetach\",\n      value: function updateAndDetach(state, updateEvents) {\n        var newState = this._update(state, updateEvents);\n\n        newState.ctx = ContextEnhancer.detachAllFromContext(newState.ctx);\n        return newState;\n      }\n    }], [{\n      key: \"detachAllFromContext\",\n      value: function detachAllFromContext(ctx$$1) {\n        var ctxWithoutAPI = Random.detach(ctx$$1);\n        ctxWithoutAPI = Events.detach(ctxWithoutAPI);\n        ctxWithoutAPI = GameLoggerCtxAPI.detach(ctxWithoutAPI);\n        return ctxWithoutAPI;\n      }\n    }]);\n\n    return ContextEnhancer;\n  }();\n  /**\n   * InitializeGame\n   *\n   * Creates the initial game state.\n   *\n   * @param {...object} game - Return value of Game().\n   * @param {...object} numPlayers - The number of players.\n   * @param {...object} multiplayer - Set to true if we are in a multiplayer client.\n   */\n\n\n  function InitializeGame(_ref) {\n    var game = _ref.game,\n        numPlayers = _ref.numPlayers,\n        setupData = _ref.setupData;\n\n    if (!numPlayers) {\n      numPlayers = 2;\n    }\n\n    var ctx$$1 = game.flow.ctx(numPlayers);\n    var seed = game.seed;\n\n    if (seed === undefined) {\n      seed = Random.seed();\n    }\n\n    ctx$$1._random = {\n      seed: seed\n    }; // Pass ctx through all the plugins that want to modify it.\n\n    ctx$$1 = ctx.setup(ctx$$1, game); // Augment ctx with the enhancers (TODO: move these into plugins).\n\n    var apiCtx = new ContextEnhancer(ctx$$1, game, ctx$$1.currentPlayer);\n    var ctxWithAPI = apiCtx.attachToContext(ctx$$1);\n    var initialG = game.setup(ctxWithAPI, setupData); // Pass G through all the plugins that want to modify it.\n\n    initialG = G.setup(initialG, ctxWithAPI, game);\n    var initial = {\n      // User managed state.\n      G: initialG,\n      // Framework managed state.\n      ctx: ctx$$1,\n      // List of {G, ctx} pairs that can be undone.\n      _undo: [],\n      // List of {G, ctx} pairs that can be redone.\n      _redo: [],\n      // A monotonically non-decreasing ID to ensure that\n      // state updates are only allowed from clients that\n      // are at the same version that the server.\n      _stateID: 0,\n      // A snapshot of this object so that actions can be\n      // replayed over it to view old snapshots.\n      // TODO: This will no longer be necessary once the\n      // log stops replaying actions (but reads the actual\n      // game states instead).\n      _initial: {}\n    };\n    var state = game.flow.init({\n      G: initial.G,\n      ctx: ctxWithAPI\n    });\n    initial.G = state.G;\n    initial._undo = state._undo;\n    state = apiCtx.updateAndDetach(state, true);\n    initial.ctx = state.ctx;\n\n    var deepCopy = function deepCopy(obj) {\n      return flatted.parse(flatted.stringify(obj));\n    };\n\n    initial._initial = deepCopy(initial);\n    return initial;\n  }\n  /**\n   * CreateGameReducer\n   *\n   * Creates the main game state reducer.\n   * @param {...object} game - Return value of Game().\n   * @param {...object} numPlayers - The number of players.\n   * @param {...object} multiplayer - Set to true if we are in a multiplayer client.\n   */\n\n\n  function CreateGameReducer(_ref2) {\n    var game = _ref2.game,\n        multiplayer = _ref2.multiplayer;\n    /**\n     * GameReducer\n     *\n     * Redux reducer that maintains the overall game state.\n     * @param {object} state - The state before the action.\n     * @param {object} action - A Redux action.\n     */\n\n    return function () {\n      var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var action = arguments.length > 1 ? arguments[1] : undefined;\n\n      switch (action.type) {\n        case GAME_EVENT:\n          {\n            state = _objectSpread({}, state, {\n              deltalog: []\n            }); // Process game events only on the server.\n            // These events like `endTurn` typically\n            // contain code that may rely on secret state\n            // and cannot be computed on the client.\n\n            if (multiplayer) {\n              return state;\n            } // Ignore the event if the player isn't allowed to make it.\n\n\n            if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerCallEvent(state.G, state.ctx, action.payload.playerID)) {\n              return state;\n            }\n\n            var apiCtx = new ContextEnhancer(state.ctx, game, action.payload.playerID);\n            state.ctx = apiCtx.attachToContext(state.ctx);\n            var newState = game.flow.processGameEvent(state, action);\n            newState = apiCtx.updateAndDetach(newState, true);\n            return _objectSpread({}, newState, {\n              _stateID: state._stateID + 1\n            });\n          }\n\n        case MAKE_MOVE:\n          {\n            state = _objectSpread({}, state, {\n              deltalog: []\n            }); // Check whether the game knows the move at all.\n\n            if (!game.moveNames.includes(action.payload.type)) {\n              return state;\n            } // Ignore the move if it isn't allowed at this point.\n\n\n            if (!game.flow.canMakeMove(state.G, state.ctx, action.payload.type)) {\n              return state;\n            } // Ignore the move if the player isn't allowed to make it.\n\n\n            if (action.payload.playerID !== null && action.payload.playerID !== undefined && !game.flow.canPlayerMakeMove(state.G, state.ctx, action.payload.playerID)) {\n              return state;\n            }\n\n            var _apiCtx = new ContextEnhancer(state.ctx, game, action.payload.playerID);\n\n            var ctxWithAPI = _apiCtx.attachToContext(state.ctx); // Process the move.\n\n\n            var G$$1 = game.processMove(state.G, action.payload, ctxWithAPI);\n\n            if (G$$1 === INVALID_MOVE) {\n              // the game declared the move as invalid.\n              return state;\n            } // Create a log entry for this move.\n\n\n            var logEntry = {\n              action: action,\n              _stateID: state._stateID,\n              turn: state.ctx.turn,\n              phase: state.ctx.phase\n            }; // don't call into events here\n\n            var _newState = _apiCtx.updateAndDetach(_objectSpread({}, state, {\n              deltalog: [logEntry]\n            }), false);\n\n            var ctx$$1 = _newState.ctx; // Undo changes to G if the move should not run on the client.\n\n            if (multiplayer && !game.flow.optimisticUpdate(G$$1, ctx$$1, action.payload)) {\n              G$$1 = state.G;\n            }\n\n            state = _objectSpread({}, _newState, {\n              G: G$$1,\n              ctx: ctx$$1,\n              _stateID: state._stateID + 1\n            }); // If we're on the client, just process the move\n            // and no triggers in multiplayer mode.\n            // These will be processed on the server, which\n            // will send back a state update.\n\n            if (multiplayer) {\n              return state;\n            } // Allow the flow reducer to process any triggers that happen after moves.\n\n\n            ctxWithAPI = _apiCtx.attachToContext(state.ctx);\n            state = game.flow.processMove(_objectSpread({}, state, {\n              ctx: ctxWithAPI\n            }), action.payload);\n            state = _apiCtx.updateAndDetach(state, true);\n            state._undo[state._undo.length - 1].ctx = state.ctx;\n            return state;\n          }\n\n        case RESET:\n        case UPDATE:\n        case SYNC:\n          {\n            return action.state;\n          }\n\n        case UNDO:\n          {\n            var _state = state,\n                _undo = _state._undo,\n                _redo = _state._redo;\n\n            if (_undo.length < 2) {\n              return state;\n            }\n\n            var last = _undo[_undo.length - 1];\n            var restore = _undo[_undo.length - 2]; // Only allow undoable moves to be undone.\n\n            if (!game.flow.canUndoMove(state.G, state.ctx, last.moveType)) {\n              return state;\n            }\n\n            return _objectSpread({}, state, {\n              G: restore.G,\n              ctx: restore.ctx,\n              _undo: _undo.slice(0, _undo.length - 1),\n              _redo: [last].concat(_toConsumableArray(_redo))\n            });\n          }\n\n        case REDO:\n          {\n            var _state2 = state,\n                _undo2 = _state2._undo,\n                _redo2 = _state2._redo;\n\n            if (_redo2.length == 0) {\n              return state;\n            }\n\n            var first = _redo2[0];\n            return _objectSpread({}, state, {\n              G: first.G,\n              ctx: first.ctx,\n              _undo: [].concat(_toConsumableArray(_undo2), [first]),\n              _redo: _redo2.slice(1)\n            });\n          }\n\n        default:\n          {\n            return state;\n          }\n      }\n    };\n  }\n\n  var GameMetadataKey = function GameMetadataKey(gameID) {\n    return \"\".concat(gameID, \":metadata\");\n  };\n  /**\n   * Redact the log.\n   *\n   * @param {Array} redactedMoves - List of moves to redact.\n   * @param {Array} log - The game log (or deltalog).\n   * @param {String} playerID - The playerID that this log is\n   *                            to be sent to.\n   */\n\n\n  function redactLog(redactedMoves, log, playerID) {\n    if (redactedMoves === undefined || log === undefined) {\n      return log;\n    }\n\n    return log.map(function (logEvent) {\n      // filter for all other players and a spectator\n      if (playerID !== null && +playerID === +logEvent.action.payload.playerID) {\n        return logEvent;\n      } // only filter moves\n\n\n      if (logEvent.action.type !== 'MAKE_MOVE') {\n        return logEvent;\n      }\n\n      var moveName = logEvent.action.payload.type;\n      var filteredEvent = logEvent;\n\n      if (redactedMoves.includes(moveName)) {\n        var newPayload = _objectSpread({}, filteredEvent.action.payload, {\n          args: undefined,\n          argsRedacted: true\n        });\n\n        filteredEvent = _objectSpread({}, filteredEvent, {\n          action: _objectSpread({}, filteredEvent.action, {\n            payload: newPayload\n          })\n        });\n      }\n\n      return filteredEvent;\n    });\n  }\n  /**\n   * Verifies that the move came from a player with the\n   * appropriate credentials.\n   */\n\n\n  var isActionFromAuthenticPlayer = function isActionFromAuthenticPlayer(_ref) {\n    var action = _ref.action,\n        gameMetadata = _ref.gameMetadata,\n        playerID = _ref.playerID;\n\n    if (!gameMetadata) {\n      return true;\n    }\n\n    if (!action.payload) {\n      return true;\n    }\n\n    var hasCredentials = Object.keys(gameMetadata.players).some(function (key) {\n      return !!(gameMetadata.players[key] && gameMetadata.players[key].credentials);\n    });\n\n    if (!hasCredentials) {\n      return true;\n    }\n\n    if (!action.payload.credentials) {\n      return false;\n    }\n\n    if (action.payload.credentials !== gameMetadata.players[playerID].credentials) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Master\n   *\n   * Class that runs the game and maintains the authoritative state.\n   * It uses the transportAPI to communicate with clients and the\n   * storageAPI to communicate with the database.\n   */\n\n\n  var Master =\n  /*#__PURE__*/\n  function () {\n    function Master(game, storageAPI, transportAPI, auth) {\n      _classCallCheck(this, Master);\n\n      this.game = game;\n      this.storageAPI = storageAPI;\n      this.transportAPI = transportAPI;\n\n      this.auth = function () {\n        return true;\n      };\n\n      if (auth === true) {\n        this.auth = isActionFromAuthenticPlayer;\n      } else if (typeof auth === 'function') {\n        this.auth = auth;\n      }\n    }\n    /**\n     * Called on each move / event made by the client.\n     * Computes the new value of the game state and returns it\n     * along with a deltalog.\n     */\n\n\n    _createClass(Master, [{\n      key: \"onUpdate\",\n      value: async function onUpdate(action, stateID, gameID, playerID) {\n        var _this = this;\n\n        var isActionAuthentic;\n\n        if (this.executeSynchronously) {\n          var gameMetadata = this.storageAPI.get(GameMetadataKey(gameID));\n          isActionAuthentic = this.auth({\n            action: action,\n            gameMetadata: gameMetadata,\n            gameID: gameID,\n            playerID: playerID\n          });\n        } else {\n          var _gameMetadata = await this.storageAPI.get(GameMetadataKey(gameID));\n\n          isActionAuthentic = this.auth({\n            action: action,\n            gameMetadata: _gameMetadata,\n            gameID: gameID,\n            playerID: playerID\n          });\n        }\n\n        if (!isActionAuthentic) {\n          return {\n            error: 'unauthorized action'\n          };\n        }\n\n        var key = gameID;\n        var state;\n\n        if (this.executeSynchronously) {\n          state = this.storageAPI.get(key);\n        } else {\n          state = await this.storageAPI.get(key);\n        }\n\n        if (state === undefined) {\n          error(\"game not found, gameID=[\".concat(key, \"]\"));\n          return {\n            error: 'game not found'\n          };\n        }\n\n        var reducer = CreateGameReducer({\n          game: this.game,\n          numPlayers: state.ctx.numPlayers\n        });\n        var store = redux.createStore(reducer, state); // Check whether the player is allowed to make the move.\n\n        if (action.type == MAKE_MOVE && !this.game.flow.canPlayerMakeMove(state.G, state.ctx, playerID)) {\n          error(\"move not processed - canPlayerMakeMove=false, playerID=[\".concat(playerID, \"]\"));\n          return;\n        } // Check whether the player is allowed to call the event.\n\n\n        if (action.type == GAME_EVENT && !this.game.flow.canPlayerCallEvent(state.G, state.ctx, playerID)) {\n          error(\"event not processed - invalid playerID=[\".concat(playerID, \"]\"));\n          return;\n        }\n\n        if (state._stateID !== stateID) {\n          error(\"invalid stateID, was=[\".concat(stateID, \"], expected=[\").concat(state._stateID, \"]\"));\n          return;\n        }\n\n        var log = store.getState().log || []; // Update server's version of the store.\n\n        store.dispatch(action);\n        state = store.getState();\n        this.transportAPI.sendAll(function (playerID) {\n          var filteredState = _objectSpread({}, state, {\n            G: _this.game.playerView(state.G, state.ctx, playerID),\n            ctx: _objectSpread({}, state.ctx, {\n              _random: undefined\n            }),\n            log: undefined,\n            deltalog: undefined,\n            _undo: [],\n            _redo: [],\n            _initial: _objectSpread({}, state._initial, {\n              _undo: [],\n              _redo: []\n            })\n          });\n\n          var log = redactLog(_this.game.flow.redactedMoves, state.deltalog, playerID);\n          return {\n            type: 'update',\n            args: [gameID, filteredState, log]\n          };\n        }); // TODO: We currently attach the log back into the state\n        // object before storing it, but this should probably\n        // sit in a different part of the database eventually.\n\n        log = [].concat(_toConsumableArray(log), _toConsumableArray(state.deltalog));\n\n        var stateWithLog = _objectSpread({}, state, {\n          log: log\n        });\n\n        if (this.executeSynchronously) {\n          this.storageAPI.set(key, stateWithLog);\n        } else {\n          await this.storageAPI.set(key, stateWithLog);\n        }\n      }\n      /**\n       * Called when the client connects / reconnects.\n       * Returns the latest game state and the entire log.\n       */\n\n    }, {\n      key: \"onSync\",\n      value: async function onSync(gameID, playerID, numPlayers) {\n        var key = gameID;\n        var state;\n\n        if (this.executeSynchronously) {\n          state = this.storageAPI.get(key);\n        } else {\n          state = await this.storageAPI.get(key);\n        } // If the game doesn't exist, then create one on demand.\n        // TODO: Move this out of the sync call.\n\n\n        if (state === undefined) {\n          state = InitializeGame({\n            game: this.game,\n            numPlayers: numPlayers\n          });\n\n          if (this.executeSynchronously) {\n            this.storageAPI.set(key, state);\n            state = this.storageAPI.get(key);\n          } else {\n            await this.storageAPI.set(key, state);\n            state = await this.storageAPI.get(key);\n          }\n        }\n\n        var filteredState = _objectSpread({}, state, {\n          G: this.game.playerView(state.G, state.ctx, playerID),\n          ctx: _objectSpread({}, state.ctx, {\n            _random: undefined\n          }),\n          log: undefined,\n          deltalog: undefined,\n          _undo: [],\n          _redo: [],\n          _initial: _objectSpread({}, state._initial, {\n            _undo: [],\n            _redo: []\n          })\n        });\n\n        var log = redactLog(this.game.flow.redactedMoves, state.log, playerID);\n        this.transportAPI.send({\n          playerID: playerID,\n          type: 'sync',\n          args: [gameID, filteredState, log]\n        });\n        return;\n      }\n    }]);\n\n    return Master;\n  }();\n  /**\n   * Creates a local version of the master that the client\n   * can interact with.\n   */\n\n\n  function LocalMaster(game) {\n    var clientCallbacks = {};\n\n    var send = function send(_ref) {\n      var type = _ref.type,\n          playerID = _ref.playerID,\n          args = _ref.args;\n      var callback = clientCallbacks[playerID];\n\n      if (callback !== undefined) {\n        callback.apply(null, [type].concat(_toConsumableArray(args)));\n      }\n    };\n\n    var sendAll = function sendAll(arg) {\n      for (var playerID in clientCallbacks) {\n        var _arg = arg(playerID),\n            type = _arg.type,\n            args = _arg.args;\n\n        send({\n          type: type,\n          playerID: playerID,\n          args: args\n        });\n      }\n    };\n\n    var master = new Master(game, new InMemory(), {\n      send: send,\n      sendAll: sendAll\n    }, false);\n    master.executeSynchronously = true;\n\n    master.connect = function (gameID, playerID, callback) {\n      clientCallbacks[playerID] = callback;\n    };\n\n    return master;\n  }\n  /**\n   * Local\n   *\n   * Transport interface that embeds a GameMaster within it\n   * that you can connect multiple clients to.\n   */\n\n\n  var Local =\n  /*#__PURE__*/\n  function () {\n    /**\n     * Creates a new Mutiplayer instance.\n     * @param {object} socket - Override for unit tests.\n     * @param {object} socketOpts - Options to pass to socket.io.\n     * @param {string} gameID - The game ID to connect to.\n     * @param {string} playerID - The player ID associated with this client.\n     * @param {string} gameName - The game type (the `name` field in `Game`).\n     * @param {string} numPlayers - The number of players.\n     * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.\n     */\n    function Local(_ref2) {\n      var master = _ref2.master,\n          store = _ref2.store,\n          gameID = _ref2.gameID,\n          playerID = _ref2.playerID,\n          gameName = _ref2.gameName,\n          numPlayers = _ref2.numPlayers;\n\n      _classCallCheck(this, Local);\n\n      this.master = master;\n      this.store = store;\n      this.gameName = gameName || 'default';\n      this.gameID = gameID || 'default';\n      this.playerID = playerID || null;\n      this.numPlayers = numPlayers || 2;\n      this.gameID = this.gameName + ':' + this.gameID;\n      this.isConnected = true;\n    }\n    /**\n     * Called when another player makes a move and the\n     * master broadcasts the update to other clients (including\n     * this one).\n     */\n\n\n    _createClass(Local, [{\n      key: \"onUpdate\",\n      value: function onUpdate(gameID, state, deltalog) {\n        var currentState = this.store.getState();\n\n        if (gameID == this.gameID && state._stateID >= currentState._stateID) {\n          var action = update(state, deltalog);\n          this.store.dispatch(action);\n        }\n      }\n      /**\n       * Called when the client first connects to the master\n       * and requests the current game state.\n       */\n\n    }, {\n      key: \"onSync\",\n      value: function onSync(gameID, state, log) {\n        if (gameID == this.gameID) {\n          var action = sync(state, log);\n          this.store.dispatch(action);\n        }\n      }\n      /**\n       * Called when an action that has to be relayed to the\n       * game master is made.\n       */\n\n    }, {\n      key: \"onAction\",\n      value: function onAction(state, action) {\n        this.master.onUpdate(action, state._stateID, this.gameID, this.playerID);\n      }\n      /**\n       * Connect to the server.\n       */\n\n    }, {\n      key: \"connect\",\n      value: function connect() {\n        var _this = this;\n\n        this.master.connect(this.gameID, this.playerID, function (type) {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          if (type == 'sync') {\n            _this.onSync.apply(_this, args);\n          }\n\n          if (type == 'update') {\n            _this.onUpdate.apply(_this, args);\n          }\n        });\n        this.master.onSync(this.gameID, this.playerID, this.numPlayers);\n      }\n      /**\n       * Subscribe to connection state changes.\n       */\n\n    }, {\n      key: \"subscribe\",\n      value: function subscribe() {}\n      /**\n       * Updates the game id.\n       * @param {string} id - The new game id.\n       */\n\n    }, {\n      key: \"updateGameID\",\n      value: function updateGameID(id) {\n        this.gameID = this.gameName + ':' + id;\n        var action = reset(null);\n        this.store.dispatch(action);\n        this.master.onSync(this.gameID, this.playerID, this.numPlayers);\n      }\n      /**\n       * Updates the player associated with this client.\n       * @param {string} id - The new player id.\n       */\n\n    }, {\n      key: \"updatePlayerID\",\n      value: function updatePlayerID(id) {\n        this.playerID = id;\n        var action = reset(null);\n        this.store.dispatch(action);\n        this.master.onSync(this.gameID, this.playerID, this.numPlayers);\n      }\n    }]);\n\n    return Local;\n  }();\n\n  var localMaster_ = null;\n  /**\n   * createDispatchers\n   *\n   * Create action dispatcher wrappers with bound playerID and credentials\n   */\n\n  function createDispatchers(storeActionType, innerActionNames, store, playerID, credentials, multiplayer) {\n    return innerActionNames.reduce(function (dispatchers, name) {\n      dispatchers[name] = function () {\n        var assumedPlayerID = playerID; // In singleplayer mode, if the client does not have a playerID\n        // associated with it, we attach the currentPlayer as playerID.\n\n        if (!multiplayer && (playerID === null || playerID === undefined)) {\n          var state = store.getState();\n          assumedPlayerID = state.ctx.currentPlayer;\n        }\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        store.dispatch(ActionCreators[storeActionType](name, args, assumedPlayerID, credentials));\n      };\n\n      return dispatchers;\n    }, {});\n  }\n  /**\n   * createEventDispatchers\n   *\n   * Creates a set of dispatchers to dispatch game flow events.\n   * @param {Array} eventNames - A list of event names.\n   * @param {object} store - The Redux store to create dispatchers for.\n   * @param {string} playerID - The ID of the player dispatching these events.\n   * @param {string} credentials - A key indicating that the player is authorized to play.\n   */\n\n\n  var createEventDispatchers = createDispatchers.bind(null, 'gameEvent');\n  /**\n   * createMoveDispatchers\n   *\n   * Creates a set of dispatchers to make moves.\n   * @param {Array} moveNames - A list of move names.\n   * @param {object} store - The Redux store to create dispatchers for.\n   * @param {string} playerID - The ID of the player dispatching these events.\n   * @param {string} credentials - A key indicating that the player is authorized to play.\n   */\n\n  var createMoveDispatchers = createDispatchers.bind(null, 'makeMove');\n  /**\n   * Implementation of Client (see below).\n   */\n\n  var _ClientImpl =\n  /*#__PURE__*/\n  function () {\n    function _ClientImpl(_ref) {\n      var _this = this;\n\n      var game = _ref.game,\n          ai = _ref.ai,\n          numPlayers = _ref.numPlayers,\n          multiplayer = _ref.multiplayer,\n          socketOpts = _ref.socketOpts,\n          gameID = _ref.gameID,\n          playerID = _ref.playerID,\n          credentials = _ref.credentials,\n          enhancer = _ref.enhancer;\n\n      _classCallCheck(this, _ClientImpl);\n\n      this.game = game;\n      this.playerID = playerID;\n      this.gameID = gameID;\n      this.credentials = credentials;\n      this.multiplayer = multiplayer;\n\n      this.subscribeCallback = function () {};\n\n      this.reducer = CreateGameReducer({\n        game: game,\n        numPlayers: numPlayers,\n        multiplayer: multiplayer\n      });\n\n      if (ai !== undefined && multiplayer === undefined) {\n        var bot = new ai.bot({\n          game: game,\n          enumerate: ai.enumerate\n        });\n\n        this.step = async function () {\n          var state = _this.store.getState();\n\n          var playerID = state.ctx.actionPlayers[0];\n\n          var _ref2 = await bot.play(state, playerID),\n              action = _ref2.action,\n              metadata = _ref2.metadata;\n\n          if (action) {\n            action.payload.metadata = metadata;\n\n            _this.store.dispatch(action);\n          }\n\n          return action;\n        };\n      }\n\n      var initialState = null;\n\n      if (multiplayer === undefined) {\n        initialState = InitializeGame({\n          game: game,\n          numPlayers: numPlayers\n        });\n      }\n\n      this.reset = function () {\n        _this.store.dispatch(reset(initialState));\n      };\n\n      this.undo = function () {\n        _this.store.dispatch(undo());\n      };\n\n      this.redo = function () {\n        _this.store.dispatch(redo());\n      };\n\n      this.store = null;\n      this.log = [];\n      /**\n       * Middleware that manages the log object.\n       * Reducers generate deltalogs, which are log events\n       * that are the result of application of a single action.\n       * The master may also send back a deltalog or the entire\n       * log depending on the type of request.\n       * The middleware below takes care of all these cases while\n       * managing the log object.\n       */\n\n      var LogMiddleware = function LogMiddleware(store) {\n        return function (next) {\n          return function (action) {\n            var result = next(action);\n            var state = store.getState();\n\n            switch (action.type) {\n              case MAKE_MOVE:\n              case GAME_EVENT:\n                {\n                  var deltalog = state.deltalog;\n                  _this.log = [].concat(_toConsumableArray(_this.log), _toConsumableArray(deltalog));\n                  break;\n                }\n\n              case RESET:\n                {\n                  _this.log = [];\n                  break;\n                }\n\n              case UPDATE:\n                {\n                  var id = -1;\n\n                  if (_this.log.length > 0) {\n                    id = _this.log[_this.log.length - 1]._stateID;\n                  }\n\n                  var _deltalog = action.deltalog || []; // Filter out actions that are already present\n                  // in the current log. This may occur when the\n                  // client adds an entry to the log followed by\n                  // the update from the master here.\n\n\n                  _deltalog = _deltalog.filter(function (l) {\n                    return l._stateID > id;\n                  });\n                  _this.log = [].concat(_toConsumableArray(_this.log), _toConsumableArray(_deltalog));\n                  break;\n                }\n\n              case SYNC:\n                {\n                  _this.log = action.log || [];\n                  break;\n                }\n            }\n\n            return result;\n          };\n        };\n      };\n      /**\n       * Middleware that intercepts actions and sends them to the master,\n       * which keeps the authoritative version of the state.\n       */\n\n\n      var TransportMiddleware = function TransportMiddleware(store) {\n        return function (next) {\n          return function (action) {\n            var baseState = store.getState();\n            var result = next(action);\n\n            if (action.clientOnly != true) {\n              _this.transport.onAction(baseState, action);\n            }\n\n            return result;\n          };\n        };\n      };\n      /**\n       * Middleware that intercepts actions and invokes the subscription callback.\n       */\n\n\n      var SubscriptionMiddleware = function SubscriptionMiddleware() {\n        return function (next) {\n          return function (action) {\n            var result = next(action);\n\n            _this.subscribeCallback();\n\n            return result;\n          };\n        };\n      };\n\n      if (enhancer !== undefined) {\n        enhancer = redux.compose(redux.applyMiddleware(SubscriptionMiddleware, TransportMiddleware, LogMiddleware), enhancer);\n      } else {\n        enhancer = redux.applyMiddleware(SubscriptionMiddleware, TransportMiddleware, LogMiddleware);\n      }\n\n      this.store = redux.createStore(this.reducer, initialState, enhancer);\n      this.transport = {\n        isConnected: true,\n        onAction: function onAction() {},\n        subscribe: function subscribe() {},\n        connect: function connect() {},\n        updateGameID: function updateGameID() {},\n        updatePlayerID: function updatePlayerID() {}\n      };\n\n      if (multiplayer !== undefined) {\n        if (multiplayer === true) {\n          multiplayer = {\n            server: ''\n          };\n        }\n\n        if (multiplayer.local === true) {\n          if (localMaster_ === null || localMaster_.game !== game) {\n            localMaster_ = new LocalMaster(game);\n          }\n\n          this.transport = new Local({\n            master: localMaster_,\n            store: this.store,\n            gameID: gameID,\n            playerID: playerID,\n            gameName: game.name,\n            numPlayers: numPlayers\n          });\n        } else if (multiplayer.server !== undefined) {\n          this.transport = new SocketIO({\n            store: this.store,\n            gameID: gameID,\n            playerID: playerID,\n            gameName: game.name,\n            numPlayers: numPlayers,\n            server: multiplayer.server,\n            socketOpts: socketOpts\n          });\n        } else if (multiplayer.transport !== undefined) {\n          this.transport = multiplayer.transport;\n        } else {\n          error('invalid multiplayer spec');\n        }\n      }\n\n      this.createDispatchers();\n    }\n\n    _createClass(_ClientImpl, [{\n      key: \"subscribe\",\n      value: function subscribe(fn) {\n        var _this2 = this;\n\n        var callback = function callback() {\n          return fn(_this2.getState());\n        };\n\n        this.transport.subscribe(callback);\n        this.subscribeCallback = callback;\n      }\n    }, {\n      key: \"getState\",\n      value: function getState() {\n        var state = this.store.getState(); // This is the state before a sync with the game master.\n\n        if (state === null) {\n          return state;\n        } // isActive.\n\n\n        var isActive = true;\n        var canPlayerMakeMove = this.game.flow.canPlayerMakeMove(state.G, state.ctx, this.playerID);\n\n        if (this.multiplayer && !canPlayerMakeMove) {\n          isActive = false;\n        }\n\n        if (!this.multiplayer && this.playerID !== null && this.playerID !== undefined && !canPlayerMakeMove) {\n          isActive = false;\n        }\n\n        if (state.ctx.gameover !== undefined) {\n          isActive = false;\n        } // Secrets are normally stripped on the server,\n        // but we also strip them here so that game developers\n        // can see their effects while prototyping.\n\n\n        var G = this.game.playerView(state.G, state.ctx, this.playerID); // Combine into return value.\n\n        var ret = _objectSpread({}, state, {\n          isActive: isActive,\n          G: G,\n          log: this.log\n        });\n\n        var isConnected = this.transport.isConnected;\n        ret = _objectSpread({}, ret, {\n          isConnected: isConnected\n        });\n        return ret;\n      }\n    }, {\n      key: \"connect\",\n      value: function connect() {\n        this.transport.connect();\n      }\n    }, {\n      key: \"createDispatchers\",\n      value: function createDispatchers() {\n        this.moves = createMoveDispatchers(this.game.moveNames, this.store, this.playerID, this.credentials, this.multiplayer);\n        this.events = createEventDispatchers(this.game.flow.enabledEventNames, this.store, this.playerID, this.credentials, this.multiplayer);\n      }\n    }, {\n      key: \"updatePlayerID\",\n      value: function updatePlayerID(playerID) {\n        this.playerID = playerID;\n        this.createDispatchers();\n        this.transport.updatePlayerID(playerID);\n      }\n    }, {\n      key: \"updateGameID\",\n      value: function updateGameID(gameID) {\n        this.gameID = gameID;\n        this.createDispatchers();\n        this.transport.updateGameID(gameID);\n      }\n    }, {\n      key: \"updateCredentials\",\n      value: function updateCredentials(credentials) {\n        this.credentials = credentials;\n        this.createDispatchers();\n      }\n    }]);\n\n    return _ClientImpl;\n  }();\n  /**\n   * Client\n   *\n   * boardgame.io JS client.\n   *\n   * @param {...object} game - The return value of `Game`.\n   * @param {...object} numPlayers - The number of players.\n   * @param {...object} multiplayer - Set to true or { server: '<host>:<port>' }\n   *                                  to make a multiplayer client. The second\n   *                                  syntax specifies a non-default socket server.\n   * @param {...object} socketOpts - Options to pass to socket.io.\n   * @param {...object} gameID - The gameID that you want to connect to.\n   * @param {...object} playerID - The playerID associated with this client.\n   * @param {...string} credentials - The authentication credentials associated with this client.\n   *\n   * Returns:\n   *   A JS object that provides an API to interact with the\n   *   game by dispatching moves and events.\n   */\n\n\n  function Client(opts) {\n    return new _ClientImpl(opts);\n  }\n  /**\n   * Client\n   *\n   * boardgame.io React client.\n   *\n   * @param {...object} game - The return value of `Game`.\n   * @param {...object} numPlayers - The number of players.\n   * @param {...object} board - The React component for the game.\n   * @param {...object} loading - (optional) The React component for the loading state.\n   * @param {...object} multiplayer - Set to true or { server: '<host>:<port>' }\n   *                                  to make a multiplayer client. The second\n   *                                  syntax specifies a non-default socket server.\n   * @param {...object} debug - Enables the Debug UI.\n   * @param {...object} enhancer - Optional enhancer to send to the Redux store\n   *\n   * Returns:\n   *   A React component that wraps board and provides an\n   *   API through props for it to interact with the framework\n   *   and dispatch actions such as MAKE_MOVE, GAME_EVENT, RESET,\n   *   UNDO and REDO.\n   */\n\n\n  function Client$1(opts) {\n    var _class, _temp;\n\n    var game = opts.game,\n        numPlayers = opts.numPlayers,\n        loading = opts.loading,\n        board = opts.board,\n        multiplayer = opts.multiplayer,\n        ai = opts.ai,\n        debug = opts.debug,\n        enhancer = opts.enhancer; // Component that is displayed before the client has synced\n    // with the game master.\n\n    if (loading === undefined) {\n      var Loading = function Loading() {\n        return React.createElement(\"div\", {\n          className: \"bgio-loading\"\n        }, \"connecting...\");\n      };\n\n      loading = Loading;\n    }\n    /*\n     * WrappedBoard\n     *\n     * The main React component that wraps the passed in\n     * board component and adds the API to its props.\n     */\n\n\n    return _temp = _class =\n    /*#__PURE__*/\n    function (_React$Component) {\n      _inherits(WrappedBoard, _React$Component);\n\n      function WrappedBoard(props) {\n        var _this;\n\n        _classCallCheck(this, WrappedBoard);\n\n        _this = _possibleConstructorReturn(this, _getPrototypeOf(WrappedBoard).call(this, props));\n\n        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n          gameStateOverride: null\n        });\n\n        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"updateGameID\", function (gameID) {\n          _this.client.updateGameID(gameID);\n\n          _this.gameID = gameID;\n\n          _this.forceUpdate();\n        });\n\n        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"updatePlayerID\", function (playerID) {\n          _this.client.updatePlayerID(playerID);\n\n          _this.playerID = playerID;\n\n          _this.forceUpdate();\n        });\n\n        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"updateCredentials\", function (credentials) {\n          _this.client.updateCredentials(credentials);\n\n          _this.credentials = credentials;\n\n          _this.forceUpdate();\n        });\n\n        _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"overrideGameState\", function (state) {\n          _this.setState({\n            gameStateOverride: state\n          });\n        });\n\n        _this.client = Client({\n          game: game,\n          ai: ai,\n          numPlayers: numPlayers,\n          multiplayer: multiplayer,\n          gameID: props.gameID,\n          playerID: props.playerID,\n          credentials: props.credentials,\n          enhancer: enhancer\n        });\n        _this.gameID = props.gameID;\n        _this.playerID = props.playerID;\n        _this.credentials = props.credentials;\n\n        _this.client.subscribe(function () {\n          return _this.forceUpdate();\n        });\n\n        return _this;\n      }\n\n      _createClass(WrappedBoard, [{\n        key: \"componentDidUpdate\",\n        value: function componentDidUpdate(prevProps) {\n          if (this.props.gameID != prevProps.gameID) {\n            this.updateGameID(this.props.gameID);\n          }\n\n          if (this.props.playerID != prevProps.playerID) {\n            this.updatePlayerID(this.props.playerID);\n          }\n\n          if (this.props.credentials != prevProps.credentials) {\n            this.updateCredentials(this.props.credentials);\n          }\n        }\n      }, {\n        key: \"componentDidMount\",\n        value: function componentDidMount() {\n          this.client.connect();\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var _board = null;\n          var _debug = null;\n          var state = this.client.getState();\n\n          var _this$props = this.props,\n              debugProp = _this$props.debug,\n              rest = _objectWithoutProperties(_this$props, [\"debug\"]);\n\n          if (this.state.gameStateOverride) {\n            state = _objectSpread({}, state, this.state.gameStateOverride);\n          }\n\n          if (state === null) {\n            return React.createElement(loading);\n          }\n\n          if (board) {\n            _board = React.createElement(board, _objectSpread({}, state, rest, {\n              isMultiplayer: multiplayer !== undefined,\n              moves: this.client.moves,\n              events: this.client.events,\n              gameID: this.gameID,\n              playerID: this.playerID,\n              step: this.client.step,\n              reset: this.client.reset,\n              undo: this.client.undo,\n              redo: this.client.redo\n            }));\n          }\n\n          if (debug !== false && debugProp) {\n            var showGameInfo = _typeof(debug) === 'object' && debug.showGameInfo;\n            var dockControls = _typeof(debug) === 'object' && debug.dockControls;\n            _debug = React.createElement(Debug, {\n              gamestate: state,\n              reducer: this.client.reducer,\n              store: this.client.store,\n              isMultiplayer: multiplayer !== undefined,\n              moves: this.client.moves,\n              events: this.client.events,\n              gameID: this.gameID,\n              playerID: this.playerID,\n              credentials: this.credentials,\n              step: this.client.step,\n              reset: this.client.reset,\n              undo: this.client.undo,\n              redo: this.client.redo,\n              visualizeAI: ai && ai.visualize,\n              overrideGameState: this.overrideGameState,\n              updateGameID: this.updateGameID,\n              updatePlayerID: this.updatePlayerID,\n              updateCredentials: this.updateCredentials,\n              showGameInfo: showGameInfo,\n              dockControls: dockControls\n            });\n          }\n\n          return React.createElement(\"div\", {\n            className: \"bgio-client\"\n          }, _debug, _board);\n        }\n      }]);\n\n      return WrappedBoard;\n    }(React.Component), _defineProperty(_class, \"propTypes\", {\n      // The ID of a game to connect to.\n      // Only relevant in multiplayer.\n      gameID: PropTypes.string,\n      // The ID of the player associated with this client.\n      // Only relevant in multiplayer.\n      playerID: PropTypes.string,\n      // This client's authentication credentials.\n      // Only relevant in multiplayer.\n      credentials: PropTypes.string,\n      // Enable / disable the Debug UI.\n      debug: PropTypes.any\n    }), _defineProperty(_class, \"defaultProps\", {\n      gameID: 'default',\n      playerID: null,\n      credentials: null,\n      debug: true\n    }), _temp;\n  }\n  /*\n   * Copyright 2018 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n\n  var _LobbyConnectionImpl =\n  /*#__PURE__*/\n  function () {\n    function _LobbyConnectionImpl(_ref) {\n      var server = _ref.server,\n          gameComponents = _ref.gameComponents,\n          playerName = _ref.playerName,\n          playerCredentials = _ref.playerCredentials;\n\n      _classCallCheck(this, _LobbyConnectionImpl);\n\n      this.gameComponents = gameComponents;\n      this.playerName = playerName || 'Visitor';\n      this.playerCredentials = playerCredentials;\n      this.server = server;\n      this.rooms = [];\n    }\n\n    _createClass(_LobbyConnectionImpl, [{\n      key: \"_baseUrl\",\n      value: function _baseUrl() {\n        return \"\".concat(this.server || '', \"/games\");\n      }\n    }, {\n      key: \"refresh\",\n      value: async function refresh() {\n        try {\n          this.rooms.length = 0;\n          var resp = await fetch(this._baseUrl());\n\n          if (resp.status !== 200) {\n            throw new Error('HTTP status ' + resp.status);\n          }\n\n          var json = await resp.json();\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = json[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var gameName = _step.value;\n              if (!this._getGameComponents(gameName)) continue;\n              var gameResp = await fetch(this._baseUrl() + '/' + gameName);\n              var gameJson = await gameResp.json();\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n              var _iteratorError2 = undefined;\n\n              try {\n                for (var _iterator2 = gameJson.rooms[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  var inst = _step2.value;\n                  inst.gameName = gameName;\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                    _iterator2.return();\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n\n              this.rooms = this.rooms.concat(gameJson.rooms);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        } catch (error) {\n          throw new Error('failed to retrieve list of games (' + error + ')');\n        }\n      }\n    }, {\n      key: \"_getGameInstance\",\n      value: function _getGameInstance(gameID) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.rooms[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var inst = _step3.value;\n            if (inst['gameID'] === gameID) return inst;\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_getGameComponents\",\n      value: function _getGameComponents(gameName) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.gameComponents[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var comp = _step4.value;\n            if (comp.game.name === gameName) return comp;\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n    }, {\n      key: \"_findPlayer\",\n      value: function _findPlayer(playerName) {\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = this.rooms[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var inst = _step5.value;\n            if (inst.players.some(function (player) {\n              return player.name === playerName;\n            })) return inst;\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n    }, {\n      key: \"join\",\n      value: async function join(gameName, gameID, playerID) {\n        try {\n          var inst = this._findPlayer(this.playerName);\n\n          if (inst) {\n            throw new Error('player has already joined ' + inst.gameID);\n          }\n\n          inst = this._getGameInstance(gameID);\n\n          if (!inst) {\n            throw new Error('game instance ' + gameID + ' not found');\n          }\n\n          var resp = await fetch(this._baseUrl() + '/' + gameName + '/' + gameID + '/join', {\n            method: 'POST',\n            body: JSON.stringify({\n              playerID: playerID,\n              playerName: this.playerName\n            }),\n            headers: {\n              'Content-Type': 'application/json'\n            }\n          });\n          if (resp.status !== 200) throw new Error('HTTP status ' + resp.status);\n          var json = await resp.json();\n          inst.players[Number.parseInt(playerID)].name = this.playerName;\n          this.playerCredentials = json.playerCredentials;\n        } catch (error) {\n          throw new Error('failed to join room ' + gameID + ' (' + error + ')');\n        }\n      }\n    }, {\n      key: \"leave\",\n      value: async function leave(gameName, gameID) {\n        try {\n          var inst = this._getGameInstance(gameID);\n\n          if (!inst) throw new Error('game instance not found');\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = inst.players[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var player = _step6.value;\n\n              if (player.name === this.playerName) {\n                var resp = await fetch(this._baseUrl() + '/' + gameName + '/' + gameID + '/leave', {\n                  method: 'POST',\n                  body: JSON.stringify({\n                    playerID: player.id,\n                    playerCredentials: this.playerCredentials\n                  }),\n                  headers: {\n                    'Content-Type': 'application/json'\n                  }\n                });\n\n                if (resp.status !== 200) {\n                  throw new Error('HTTP status ' + resp.status);\n                }\n\n                delete player.name;\n                delete this.playerCredentials;\n                return;\n              }\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n\n          throw new Error('player not found in room');\n        } catch (error) {\n          throw new Error('failed to leave room ' + gameID + ' (' + error + ')');\n        }\n      }\n    }, {\n      key: \"disconnect\",\n      value: async function disconnect() {\n        var inst = this._findPlayer(this.playerName);\n\n        if (inst) {\n          await this.leave(inst.gameName, inst.gameID);\n        }\n\n        this.rooms = [];\n        this.playerName = 'Visitor';\n      }\n    }, {\n      key: \"create\",\n      value: async function create(gameName, numPlayers) {\n        try {\n          var comp = this._getGameComponents(gameName);\n\n          if (!comp) throw new Error('game not found');\n          if (numPlayers < comp.game.minPlayers || numPlayers > comp.game.maxPlayers) throw new Error('invalid number of players ' + numPlayers);\n          var resp = await fetch(this._baseUrl() + '/' + gameName + '/create', {\n            method: 'POST',\n            body: JSON.stringify({\n              numPlayers: numPlayers\n            }),\n            headers: {\n              'Content-Type': 'application/json'\n            }\n          });\n          if (resp.status !== 200) throw new Error('HTTP status ' + resp.status);\n        } catch (error) {\n          throw new Error('failed to create room for ' + gameName + ' (' + error + ')');\n        }\n      }\n    }]);\n\n    return _LobbyConnectionImpl;\n  }();\n  /**\n   * LobbyConnection\n   *\n   * Lobby model.\n   *\n   * @param {string}   server - '<host>:<port>' of the server.\n   * @param {Array}    gameComponents - A map of Board and Game objects for the supported games.\n   * @param {string}   playerName - The name of the player.\n   * @param {string}   playerCredentials - The credentials currently used by the player, if any.\n   *\n   * Returns:\n   *   A JS object that synchronizes the list of running game instances with the server and provides an API to create/join/start instances.\n   */\n\n\n  function LobbyConnection(opts) {\n    return new _LobbyConnectionImpl(opts);\n  }\n\n  var LobbyLoginForm =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(LobbyLoginForm, _React$Component);\n\n    function LobbyLoginForm() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      _classCallCheck(this, LobbyLoginForm);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LobbyLoginForm)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n        playerName: _this.props.playerName,\n        nameErrorMsg: ''\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onClickEnter\", function () {\n        if (_this.state.playerName === '') return;\n\n        _this.props.onEnter(_this.state.playerName);\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onKeyPress\", function (event) {\n        if (event.key === 'Enter') {\n          _this.onClickEnter();\n        }\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onChangePlayerName\", function (event) {\n        var name = event.target.value.trim();\n\n        _this.setState({\n          playerName: name,\n          nameErrorMsg: name.length > 0 ? '' : 'empty player name'\n        });\n      });\n\n      return _this;\n    }\n\n    _createClass(LobbyLoginForm, [{\n      key: \"render\",\n      value: function render() {\n        return React.createElement(\"div\", null, React.createElement(\"p\", {\n          className: \"phase-title\"\n        }, \"Choose a player name:\"), React.createElement(\"input\", {\n          type: \"text\",\n          value: this.state.playerName,\n          onChange: this.onChangePlayerName,\n          onKeyPress: this.onKeyPress\n        }), React.createElement(\"span\", {\n          className: \"buttons\"\n        }, React.createElement(\"button\", {\n          className: \"buttons\",\n          onClick: this.onClickEnter\n        }, \"Enter\")), React.createElement(\"br\", null), React.createElement(\"span\", {\n          className: \"error-msg\"\n        }, this.state.nameErrorMsg, React.createElement(\"br\", null)));\n      }\n    }]);\n\n    return LobbyLoginForm;\n  }(React.Component);\n\n  _defineProperty(LobbyLoginForm, \"propTypes\", {\n    playerName: PropTypes.string,\n    onEnter: PropTypes.func.isRequired\n  });\n\n  _defineProperty(LobbyLoginForm, \"defaultProps\", {\n    playerName: ''\n  });\n\n  var LobbyRoomInstance =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(LobbyRoomInstance, _React$Component);\n\n    function LobbyRoomInstance() {\n      var _getPrototypeOf2;\n\n      var _this;\n\n      _classCallCheck(this, LobbyRoomInstance);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(LobbyRoomInstance)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_createSeat\", function (player) {\n        return player.name || '[free]';\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_createInstanceButtons\", function (inst) {\n        var playerSeat = inst.players.find(function (player) {\n          return player.name === _this.props.playerName;\n        });\n        var freeSeat = inst.players.find(function (player) {\n          return !player.name;\n        });\n\n        if (playerSeat && freeSeat) {\n          // already seated: waiting for game to start\n          return React.createElement(\"button\", {\n            onClick: function onClick() {\n              return _this.props.onClickLeave(inst.gameName, inst.gameID);\n            }\n          }, \"Leave\");\n        }\n\n        if (freeSeat) {\n          // at least 1 seat is available\n          return React.createElement(\"button\", {\n            onClick: function onClick() {\n              return _this.props.onClickJoin(inst.gameName, inst.gameID, '' + freeSeat.id);\n            }\n          }, \"Join\");\n        } // room is full\n\n\n        if (playerSeat) {\n          return React.createElement(\"button\", {\n            onClick: function onClick() {\n              return _this.props.onClickPlay(inst.gameName, {\n                gameID: inst.gameID,\n                playerID: '' + playerSeat.id,\n                numPlayers: inst.players.length\n              });\n            }\n          }, \"Play\");\n        } // allow spectating\n\n\n        return React.createElement(\"button\", {\n          onClick: function onClick() {\n            return _this.props.onClickPlay(inst.gameName, {\n              gameID: inst.gameID,\n              numPlayers: inst.players.length\n            });\n          }\n        }, \"Spectate\");\n      });\n\n      return _this;\n    }\n\n    _createClass(LobbyRoomInstance, [{\n      key: \"render\",\n      value: function render() {\n        var room = this.props.room;\n        var status = 'OPEN';\n\n        if (!room.players.find(function (player) {\n          return !player.name;\n        })) {\n          status = 'RUNNING';\n        }\n\n        return React.createElement(\"tr\", {\n          key: 'line-' + room.gameID\n        }, React.createElement(\"td\", {\n          key: 'cell-name-' + room.gameID\n        }, room.gameName), React.createElement(\"td\", {\n          key: 'cell-status-' + room.gameID\n        }, status), React.createElement(\"td\", {\n          key: 'cell-seats-' + room.gameID\n        }, room.players.map(this._createSeat).join(', ')), React.createElement(\"td\", {\n          key: 'cell-buttons-' + room.gameID\n        }, this._createInstanceButtons(room)));\n      }\n    }]);\n\n    return LobbyRoomInstance;\n  }(React.Component);\n\n  _defineProperty(LobbyRoomInstance, \"propTypes\", {\n    room: PropTypes.shape({\n      gameName: PropTypes.string.isRequired,\n      gameID: PropTypes.string.isRequired,\n      players: PropTypes.array.isRequired\n    }),\n    playerName: PropTypes.string.isRequired,\n    onClickJoin: PropTypes.func.isRequired,\n    onClickLeave: PropTypes.func.isRequired,\n    onClickPlay: PropTypes.func.isRequired\n  });\n\n  var LobbyCreateRoomForm =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(LobbyCreateRoomForm, _React$Component);\n\n    function LobbyCreateRoomForm(props) {\n      var _this;\n\n      _classCallCheck(this, LobbyCreateRoomForm);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(LobbyCreateRoomForm).call(this, props));\n      /* fix min and max number of players */\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n        selectedGame: 0,\n        numPlayers: 2\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_createGameNameOption\", function (game, idx) {\n        return React.createElement(\"option\", {\n          key: 'name-option-' + idx,\n          value: idx\n        }, game.game.name);\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_createNumPlayersOption\", function (idx) {\n        return React.createElement(\"option\", {\n          key: 'num-option-' + idx,\n          value: idx\n        }, idx);\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_createNumPlayersRange\", function (game) {\n        return _toConsumableArray(new Array(game.maxPlayers + 1).keys()).slice(game.minPlayers);\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onChangeNumPlayers\", function (event) {\n        _this.setState({\n          numPlayers: Number.parseInt(event.target.value)\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onChangeSelectedGame\", function (event) {\n        var idx = Number.parseInt(event.target.value);\n\n        _this.setState({\n          selectedGame: idx,\n          numPlayers: _this.props.games[idx].game.minPlayers\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"onClickCreate\", function () {\n        _this.props.createGame(_this.props.games[_this.state.selectedGame].game.name, _this.state.numPlayers);\n      });\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = props.games[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var game = _step.value;\n          var game_details = game.game;\n\n          if (!game_details.minPlayers) {\n            game_details.minPlayers = 1;\n          }\n\n          if (!game_details.maxPlayers) {\n            game_details.maxPlayers = 4;\n          }\n\n          console.assert(game_details.maxPlayers >= game_details.minPlayers);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      _this.state = {\n        selectedGame: 0,\n        numPlayers: props.games[0].game.minPlayers\n      };\n      return _this;\n    }\n\n    _createClass(LobbyCreateRoomForm, [{\n      key: \"render\",\n      value: function render() {\n        var _this2 = this;\n\n        return React.createElement(\"div\", null, React.createElement(\"select\", {\n          value: this.state.selectedGame,\n          onChange: function onChange(evt) {\n            return _this2.onChangeSelectedGame(evt);\n          }\n        }, this.props.games.map(this._createGameNameOption)), React.createElement(\"span\", null, \"Players:\"), React.createElement(\"select\", {\n          value: this.state.numPlayers,\n          onChange: this.onChangeNumPlayers\n        }, this._createNumPlayersRange(this.props.games[this.state.selectedGame].game).map(this._createNumPlayersOption)), React.createElement(\"span\", {\n          className: \"buttons\"\n        }, React.createElement(\"button\", {\n          onClick: this.onClickCreate\n        }, \"Create\")));\n      }\n    }]);\n\n    return LobbyCreateRoomForm;\n  }(React.Component);\n\n  _defineProperty(LobbyCreateRoomForm, \"propTypes\", {\n    games: PropTypes.array.isRequired,\n    createGame: PropTypes.func.isRequired\n  });\n\n  var LobbyPhases = {\n    ENTER: 'enter',\n    PLAY: 'play',\n    LIST: 'list'\n  };\n  /**\n   * Lobby\n   *\n   * React lobby component.\n   *\n   * @param {Array}  gameComponents - An array of Board and Game objects for the supported games.\n   * @param {string} lobbyServer - Address of the lobby server (for example 'localhost:8000').\n   *                               If not set, defaults to the server that served the page.\n   * @param {string} gameServer - Address of the game server (for example 'localhost:8001').\n   *                              If not set, defaults to the server that served the page.\n   * @param {function} clientFactory - Function that is used to create the game clients.\n   * @param {bool}   debug - Enable debug information (default: false).\n   *\n   * Returns:\n   *   A React component that provides a UI to create, list, join, leave, play or spectate game instances.\n   */\n\n  var Lobby =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(Lobby, _React$Component);\n\n    function Lobby(_props) {\n      var _this;\n\n      _classCallCheck(this, Lobby);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Lobby).call(this, _props));\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"state\", {\n        phase: LobbyPhases.ENTER,\n        playerName: 'Visitor',\n        runningGame: null,\n        errorMsg: '',\n        credentialStore: {}\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_createConnection\", function (props) {\n        var name = _this.state.playerName;\n        _this.connection = LobbyConnection({\n          server: props.lobbyServer,\n          gameComponents: props.gameComponents,\n          playerName: name,\n          playerCredentials: _this.state.credentialStore[name]\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_updateCredentials\", function (playerName, credentials) {\n        _this.setState(function (prevState) {\n          // clone store or componentDidUpdate will not be triggered\n          var store = Object.assign({}, prevState.credentialStore);\n          store[[playerName]] = credentials;\n          return {\n            credentialStore: store\n          };\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_updateConnection\", async function () {\n        await _this.connection.refresh();\n\n        _this.forceUpdate();\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_enterLobby\", function (playerName) {\n        _this.setState({\n          playerName: playerName,\n          phase: LobbyPhases.LIST\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_exitLobby\", async function () {\n        await _this.connection.disconnect();\n\n        _this.setState({\n          phase: LobbyPhases.ENTER,\n          errorMsg: ''\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_createRoom\", async function (gameName, numPlayers) {\n        try {\n          await _this.connection.create(gameName, numPlayers);\n          await _this.connection.refresh(); // rerender\n\n          _this.setState({});\n        } catch (error) {\n          _this.setState({\n            errorMsg: error.message\n          });\n        }\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_joinRoom\", async function (gameName, gameID, playerID) {\n        try {\n          await _this.connection.join(gameName, gameID, playerID);\n          await _this.connection.refresh();\n\n          _this._updateCredentials(_this.connection.playerName, _this.connection.playerCredentials);\n        } catch (error) {\n          _this.setState({\n            errorMsg: error.message\n          });\n        }\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_leaveRoom\", async function (gameName, gameID) {\n        try {\n          await _this.connection.leave(gameName, gameID);\n          await _this.connection.refresh();\n\n          _this._updateCredentials(_this.connection.playerName, _this.connection.playerCredentials);\n        } catch (error) {\n          _this.setState({\n            errorMsg: error.message\n          });\n        }\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_startGame\", function (gameName, gameOpts) {\n        var gameCode = _this.connection._getGameComponents(gameName);\n\n        if (!gameCode) {\n          _this.setState({\n            errorMsg: 'game ' + gameName + ' not supported'\n          });\n\n          return;\n        }\n\n        var multiplayer = undefined;\n\n        if (gameOpts.numPlayers > 1) {\n          if (_this.props.gameServer) {\n            multiplayer = {\n              server: _this.props.gameServer\n            };\n          } else {\n            multiplayer = true;\n          }\n        }\n\n        var app = _this.props.clientFactory({\n          game: gameCode.game,\n          board: gameCode.board,\n          debug: _this.props.debug,\n          multiplayer: multiplayer\n        });\n\n        var game = {\n          app: app,\n          gameID: gameOpts.gameID,\n          playerID: gameOpts.numPlayers > 1 ? gameOpts.playerID : null,\n          credentials: _this.connection.playerCredentials\n        };\n\n        _this.setState({\n          phase: LobbyPhases.PLAY,\n          runningGame: game\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_exitRoom\", function () {\n        _this.setState({\n          phase: LobbyPhases.LIST,\n          runningGame: null\n        });\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"_getPhaseVisibility\", function (phase) {\n        return _this.state.phase !== phase ? 'hidden' : 'phase';\n      });\n\n      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"renderRooms\", function (rooms, playerName) {\n        return rooms.map(function (room) {\n          var gameID = room.gameID,\n              gameName = room.gameName,\n              players = room.players;\n          return React.createElement(LobbyRoomInstance, {\n            key: 'instance-' + gameID,\n            room: {\n              gameID: gameID,\n              gameName: gameName,\n              players: Object.values(players)\n            },\n            playerName: playerName,\n            onClickJoin: _this._joinRoom,\n            onClickLeave: _this._leaveRoom,\n            onClickPlay: _this._startGame\n          });\n        });\n      });\n\n      _this._createConnection(_this.props);\n\n      _this._updateConnection();\n\n      return _this;\n    }\n\n    _createClass(Lobby, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var cookie = Cookies.load('lobbyState') || {};\n\n        if (cookie.phase && cookie.phase === LobbyPhases.PLAY) {\n          cookie.phase = LobbyPhases.LIST;\n        }\n\n        this.setState({\n          phase: cookie.phase || LobbyPhases.ENTER,\n          playerName: cookie.playerName || 'Visitor',\n          credentialStore: cookie.credentialStore || {}\n        });\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps, prevState) {\n        var name = this.state.playerName;\n        var creds = this.state.credentialStore[name];\n\n        if (prevState.phase !== this.state.phase || prevState.credentialStore[name] !== creds || prevState.playerName !== name) {\n          this._createConnection(this.props);\n\n          this._updateConnection();\n\n          var cookie = {\n            phase: this.state.phase,\n            playerName: name,\n            credentialStore: this.state.credentialStore\n          };\n          Cookies.save('lobbyState', cookie, {\n            path: '/'\n          });\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var _this$props = this.props,\n            gameComponents = _this$props.gameComponents,\n            renderer = _this$props.renderer;\n        var _this$state = this.state,\n            errorMsg = _this$state.errorMsg,\n            playerName = _this$state.playerName,\n            phase = _this$state.phase,\n            runningGame = _this$state.runningGame;\n\n        if (renderer) {\n          return renderer({\n            errorMsg: errorMsg,\n            gameComponents: gameComponents,\n            rooms: this.connection.rooms,\n            phase: phase,\n            playerName: playerName,\n            runningGame: runningGame,\n            handleEnterLobby: this._enterLobby,\n            handleExitLobby: this._exitLobby,\n            handleCreateRoom: this._createRoom,\n            handleJoinRoom: this._joinRoom,\n            handleLeaveRoom: this._leaveRoom,\n            handleExitRoom: this._exitRoom,\n            handleRefreshRooms: this._updateConnection,\n            handleStartGame: this._startGame\n          });\n        }\n\n        return React.createElement(\"div\", {\n          id: \"lobby-view\",\n          style: {\n            padding: 50\n          }\n        }, React.createElement(\"div\", {\n          className: this._getPhaseVisibility(LobbyPhases.ENTER)\n        }, React.createElement(LobbyLoginForm, {\n          key: playerName,\n          playerName: playerName,\n          onEnter: this._enterLobby\n        })), React.createElement(\"div\", {\n          className: this._getPhaseVisibility(LobbyPhases.LIST)\n        }, React.createElement(\"p\", null, \"Welcome, \", playerName), React.createElement(\"div\", {\n          className: \"phase-title\",\n          id: \"game-creation\"\n        }, React.createElement(\"span\", null, \"Create a room:\"), React.createElement(LobbyCreateRoomForm, {\n          games: gameComponents,\n          createGame: this._createRoom\n        })), React.createElement(\"p\", {\n          className: \"phase-title\"\n        }, \"Join a room:\"), React.createElement(\"div\", {\n          id: \"instances\"\n        }, React.createElement(\"table\", null, React.createElement(\"tbody\", null, this.renderRooms(this.connection.rooms, playerName))), React.createElement(\"span\", {\n          className: \"error-msg\"\n        }, errorMsg, React.createElement(\"br\", null))), React.createElement(\"p\", {\n          className: \"phase-title\"\n        }, \"Rooms that become empty are automatically deleted.\")), React.createElement(\"div\", {\n          className: this._getPhaseVisibility(LobbyPhases.PLAY)\n        }, runningGame && React.createElement(runningGame.app, {\n          gameID: runningGame.gameID,\n          playerID: runningGame.playerID,\n          credentials: runningGame.credentials\n        }), React.createElement(\"div\", {\n          className: \"buttons\",\n          id: \"game-exit\"\n        }, React.createElement(\"button\", {\n          onClick: this._exitRoom\n        }, \"Exit game\"))), React.createElement(\"div\", {\n          className: \"buttons\",\n          id: \"lobby-exit\"\n        }, React.createElement(\"button\", {\n          onClick: this._exitLobby\n        }, \"Exit lobby\")));\n      }\n    }]);\n\n    return Lobby;\n  }(React.Component);\n\n  _defineProperty(Lobby, \"propTypes\", {\n    gameComponents: PropTypes.array.isRequired,\n    lobbyServer: PropTypes.string,\n    gameServer: PropTypes.string,\n    debug: PropTypes.bool,\n    clientFactory: PropTypes.func\n  });\n\n  _defineProperty(Lobby, \"defaultProps\", {\n    debug: false,\n    clientFactory: Client$1\n  });\n  /*\n   * Copyright 2017 The boardgame.io Authors\n   *\n   * Use of this source code is governed by a MIT-style\n   * license that can be found in the LICENSE file or at\n   * https://opensource.org/licenses/MIT.\n   */\n\n\n  exports.Client = Client$1;\n  exports.Lobby = Lobby;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}