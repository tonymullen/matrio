'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var path = require('path');
// const printAST = require('ast-pretty-print')

var _require = require('babel-plugin-macros'),
    createMacro = _require.createMacro;

var glob = require('glob');

module.exports = createMacro(prevalMacros);

function prevalMacros(_ref) {
  var references = _ref.references,
      state = _ref.state,
      babel = _ref.babel;

  references.default.forEach(function (referencePath) {
    if (referencePath.parentPath.type === 'CallExpression') {
      asyncVersion({ referencePath, state, babel });
    } else if (referencePath.parentPath.type === 'MemberExpression' && referencePath.parentPath.node.property.name === 'sync') {
      syncVersion({ referencePath, state, babel });
    } else if (referencePath.parentPath.type === 'MemberExpression' && referencePath.parentPath.node.property.name === 'deferred') {
      deferredVersion({ referencePath, state, babel });
    } else {
      throw new Error(`This is not supported: \`${referencePath.findParent(babel.types.isExpression).getSource()}\`. Please see the import-all.macro documentation`);
    }
  });
}

function syncVersion(_ref2) {
  var _program$node$body;

  var referencePath = _ref2.referencePath,
      state = _ref2.state,
      babel = _ref2.babel;
  var t = babel.types;
  var filename = state.file.opts.filename;

  var importSources = getImportSources(referencePath.parentPath.parentPath, path.dirname(filename));

  var _importSources$reduce = importSources.reduce(function (all, source) {
    var id = referencePath.scope.generateUidIdentifier(source);
    all.importNodes.push(t.importDeclaration([t.importNamespaceSpecifier(id)], t.stringLiteral(source)));
    all.objectProperties.push(t.objectProperty(t.stringLiteral(source), id));
    return all;
  }, { importNodes: [], objectProperties: [] }),
      importNodes = _importSources$reduce.importNodes,
      objectProperties = _importSources$reduce.objectProperties;

  var objectExpression = t.objectExpression(objectProperties);

  var program = state.file.path;
  (_program$node$body = program.node.body).unshift.apply(_program$node$body, _toConsumableArray(importNodes));
  referencePath.parentPath.parentPath.replaceWith(objectExpression);
}

function asyncVersion(_ref3) {
  var referencePath = _ref3.referencePath,
      state = _ref3.state,
      babel = _ref3.babel;
  var t = babel.types,
      template = babel.template;
  var filename = state.file.opts.filename;

  var promiseTemplate = template(`
    Promise.all(ALL_IMPORTS).then(function importAllHandler(importVals) {
      return IMPORT_OBJ
    })
  `);
  var importSources = getImportSources(referencePath.parentPath, path.dirname(filename));

  var _importSources$reduce2 = importSources.reduce(function (all, source, index) {
    all.dynamicImports.push(t.callExpression(t.import(), [t.stringLiteral(source)]));

    all.objectProperties.push(t.objectProperty(t.stringLiteral(source), t.memberExpression(t.identifier('importVals'), t.numericLiteral(index), true)));
    return all;
  }, { dynamicImports: [], objectProperties: [] }),
      dynamicImports = _importSources$reduce2.dynamicImports,
      objectProperties = _importSources$reduce2.objectProperties;

  referencePath.parentPath.replaceWith(promiseTemplate({
    ALL_IMPORTS: t.arrayExpression(dynamicImports),
    IMPORT_OBJ: t.objectExpression(objectProperties)
  }));
}

function deferredVersion(_ref4) {
  var referencePath = _ref4.referencePath,
      state = _ref4.state,
      babel = _ref4.babel;
  var t = babel.types;
  var filename = state.file.opts.filename;

  var importSources = getImportSources(referencePath.parentPath.parentPath, path.dirname(filename));

  var objectProperties = importSources.map(function (source) {
    return t.objectProperty(t.stringLiteral(source), t.functionExpression(null, [], t.blockStatement([t.returnStatement(t.callExpression(t.import(), [t.stringLiteral(source)]))])));
  });

  var objectExpression = t.objectExpression(objectProperties);

  referencePath.parentPath.parentPath.replaceWith(objectExpression);
}

function getImportSources(callExpressionPath, cwd) {
  var globValue = void 0;
  try {
    globValue = callExpressionPath.get('arguments')[0].evaluate().value;
  } catch (error) {
    // ignore the error
    // add a console.log here if you need to know more specifically what's up...
  }
  if (!globValue) {
    throw new Error(`There was a problem evaluating the value of the argument for the code: ${callExpressionPath.getSource()}. ` + `If the value is dynamic, please make sure that its value is statically deterministic.`);
  }

  return glob.sync(globValue, { cwd });
}